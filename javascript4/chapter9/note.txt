代理与反射

·代理基础
·代理捕获器与反射方法
·代理模式

ECMAScript6新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标
对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响
目标对象之前，可以在代理对象中对这些操作加以控制。

对刚刚接触这个主题的开发者而言，代理是一个比较模糊的概念，而且还夹杂着很多新属于。

注意： 在ES6之前，ECMAScript中并没有类似代理的特性。由于代理是一种新的基础性语言能力。很多转义程序
都不能把代理行为转换为之前的ECMAScript代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在
百分百支持他们的平台上有用。可以监测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此
并不推荐。

9.1 代理基础

正如本章开头所介绍的，代理是目标对象的抽象。从很多方面看，代理类似c++指针，因为它可以用作目标对象
的替身，但又完全独立于目标对象。目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过
代理施予的行为。

注意： ECMAScript代理与c++指针有重大区别，不过作为一种有助于理解的类比，指针在概念上还是比较合适的
结构。

9.1.1 创建空代理

最简单的代理是空代理，即除了作为一个抽象的目标对象，声明也不做。默认情况下，在代理对象上执行的所有
操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之
关联的代理对象。

代理是使用Proxy构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个
参数都会抛出TypeError。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让左右操作
畅通无阻地抵达目标对象。

如下所示：在代理对象上执行的任何操作实际上都会应用到目标对象。唯一可感知的不同就是代码中操作的是代理
对象。

const target = {
  id: 'target'
}
const handler = {}

const proxy = new Proxy(target, handler)

console.log(target.id)  //target
console.log(proxy.id)   //target

//给目标属性赋值会反映在两个对象上，因为两个对象访问的是同一个值
target.id = 'foo'
console.log(target.id)  //foo
console.log(proxy.id)   //foo

//给代理属性赋值会反映在两个对象上，因为这两个赋值会转移到目标对象
proxy.id = 'bar'
console.log(target.id)
console.log(proxy.id)

//hasOwnProperty()方法在两个地方都会应用到目标对象
console.log(target.hasOwnProperty('id'))  //true
console.log(proxy.hasOwnProperty('id'))   //true

//Proxy.prototype是undefined，因此不能使用Instanceof操作符
console.log(target instanceof Proxy)
//Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check

console.log(proxy instanceof Proxy)
//Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check

//严格相等可以用来区分代理和目标
console.log(target === proxy)   //false

9.1.2 定义捕获器

使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。
每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象
上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，
从儿拦截并修改相应的行为。

注意： 捕获器（trap）是从操作系统中借用的概念。在操作系统中，捕获器是程序流中的一个同步中断，可以
暂停程序流，转而执行一段子例程，之后再返回原始程序流。

例：可以定义一个get()捕获器，再ECMAScript操作以某种形式调用get()时触发。下面的例子定义了一个get()
捕获器：

const target = {
  foo: 'bar'
}

const handler = {
  //捕获器在处理程序对象中以方法名为键
  get() {
    return 'handler override'
  }
}

const proxy = new Proxy(target, handler);

这样，当通过对象执行get()操作时，就会触发定义的get()捕获器。当然，get()不是ECMAScript对象可以调用
的方法。这个操作在javascript代码中可以通过多种形式触发并被get()捕获器拦截到。proxy[property]、
proxy.property或Object.create(proxy)[property]等操作都会触发基本的get()操作以获取属性。因此
所有这些操作只要发生在代理对象上，就会触发get()捕获器。注意，只有在代理对象上执行这些操作才会触发
捕获器。在目标对象上执行这些操作仍然会产生正常的行为。

const target = {
  foo: 'bar'
}
const handler = {
  get(){
    return 'handler override'
  }
}

const proxy = new Proxy(target, handler)
console.log(target.foo)     //bar
console.log(proxy.foo)      //handler override

console.log(target['foo'])  //bar
console.log(proxy['foo'])   //handler override

console.log(Object.create(target)['foo']) //bar
console.log(Object.create(proxy)['foo'])  //handler override

9.1.3 捕获器参数和反射API

所有捕获器都可以访问相应的参数，基于这些参数可以重建捕获方法的原始行为。比如，get()捕获器会接收
到目标对象、要查询的属性和代理对象三个参数。

const target = {
  foo: 'bar'
}

const handler = {
  get(trapTarget, property, receiver){
    console.log(trapTarget === target)  //true
    console.log(property)               //foo
    console.log(receiver)               //Proxy {foo:"bar"}
  }
}
const proxy = new Proxy(target, handler)
console.log(proxy.foo)  //undefined

有了这些参数，就可也重建捕获方法的原始行为：
const target = {
  foo: 'bar'
}
const handler = {
  get(trapTarget, property, receiver){
    return trapTarget[property]
  }
}
const proxy = new Proxy(target, handler)
console.log(proxy.foo)  //bar
console.log(target.foo) //bar