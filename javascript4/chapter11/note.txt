期约与异步函数

·异步函数
·期约
·异步函数

ECMAScript6新增了正式的Promise(期约)引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了
async和await关键字定义异步函数的机制。

注意： 本章实例将大量使用异步日志输出的方式setTimeout(console.log, 0, ...params)，旨在演示执行
顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约
等返回的值达到其最终状态。

此外，浏览器控制台的输出经常能打印出javascript允许中无法获取的对象信息（比如期约的状态）。这个特性
在示例中广泛使用，以便辅助读者理解相关概念。

11.1 异步编程

同步行为和异步行为的对立统一是计算机的一个基础概念。特别是在javascript这种单线程事件循环中，同步
操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待
其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么
任何时候都可以使用。

11.1.1 同步与异步

同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照他们出现的顺序来执行，而每条指令执行后
也能立即获得存储在系统本地（入寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意
位置是的状态（比如变量的值）。
let x = 3;
x = x + 4;
在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到
最后一条指令执行完毕，存储在x的值就立即可以使用.

这两行javascript代码对应的低级指令（从javascript到x86）并不难想象。首先，操作系统会在栈内存上分配
一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令
都是在单个线程中按照顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。

相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制
进程等待一个长事件的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如
像远程服务器发送请求并等待响应，那么就会出现长事件的等待。

let x = 3;
setTimeout(() => x = x + 4, 100)

这段程序最终与同步代码执行的认为一样，都是把两个数加在一起，但这一次执行线程不知道x值何时会改变。
因为这取决于回调何时从消息队列出列并执行。

异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作
及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对
javascript运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之
后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。

为了让后续代码能够使用x，异步执行的函数需要在更新x的值以后通知其他代码。如果程序不需要这个值，那么
就只管继续执行，不必等待这个结果了。

设计一个能够知道x什么时候可以读取的系统是非常难的。javascript在实现这样一个系统的过程中也经历了
几次迭代。

11.1.2 以往的异步编程模式

异步行为是javascript的基础，但以前的实现不理想。早期的javascript中，只支持定义回调函数来表明异步
操作完成。串联多个异步操作时常见的问题。通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。

假设有以下异步函数，使用setTimeout在一秒钟之后执行某些操作：
function double(value){
  setTimeout(() => setTimeout(console.log, 0, value * 2), 1000)
}
double(3)

这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout可以定义一个在指定时间之后
会被调用的回调函数。对这个例子而言，1000毫秒之后，javascript运行时会把回调函数推到自己的消息队列
上去等待执行。推到队列之后，回调什么时候出列被执行对javascript代码就完全不可见了。还有一点，double()
函数在setTimeout成功调度异步操作之后会立即退出。

1.异步返回值

假设setTimeout操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略
是给异步操作提供一个回调函数，这个回调函数中包含要使用异步返回值的代码（作为回调的参数）
function double(value, callback){
  setTimeout(() => callback(value * 2), 1000)
}

double(3, x => console.log(`I was given: ${x}`))
//I was given: 6

这里的setTimeout调用告诉javascript运行时 在1000毫秒后把一个函数推到消息队列上。这个函数会由
运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然时可用的。

2.失败处理

异步操作的失败处理在回调模型中也要考虑，因此自然就会出现成功回调和失败回调。

function double(value, success, failure){
  setTimeout(() => {
    try{
      if(typeof value !== 'number'){
        throw 'Must provide number as first argument'
      }
      success(2 * value)
    }catch(e){
      failure(e)
    }
  }, 1000)
}

const successCallback = x => console.log(`Success: ${x}`)
const failureCallback = x => console.log(`Failure: ${x}`)

这种模式以及不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间能存在，只有
预备好将这个短时间内 存在的值作为参数的回调才能接收到它。

3.嵌套异步回调

如果异步返回值又依赖另一个异步返回值，那么回调的情况会进一步复杂。在实际的代码中，这就要求嵌套
回调

随着代码越来越复杂，回调策略是不具有扩展性的。嵌套回调的代码维护起来就是噩梦

11.2 期约

期约是对尚不存在结果的一个替身。

11.2.1 Promises/A+规范

早期的期约机制在jquery和Dojo中是以Deferred API的形式出现的。到2010年，CommonJS项目实现的
Promises/A规范日益流行起来。

11.2.2 期约基础

ECMAScript6新增的引用类型Promise，可用通过new操作符来实例化。创建新期约时需要传入执行器(executor)
函数作为参数，下面的例子使用了一个空函数对象来应付一下解释器

let p = new Promise(() => {})
setTimeout(console.log, 0, p)

之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出异常

1.期约状态机

把一个期约实例传给console.log()时，控制台输出(可能因浏览器不同而略有差异)表明该实例处于待定
(pending)状态。如前所述，期约是一个有状态的对象，可能处于如下3中状态之一：
·待定(pending)
·兑现(fulfilled,有时候也称为“解决”，resolved)
·拒绝(rejected)

待定：是期约的最初始状态，在待定状态下，期约可用落定（settled）为代表成功的兑现状态，或者代表
失败的拒绝状态。无论落定为那种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不在改变。
而且，也不能保证期约必然会脱离待定状态。因此组织合理的代码无论期约解决（resolve）还是拒绝(reject),
甚至永远处于待定(pending)状态，都应该具有恰当行为。

重要的是，期约的状态是私有的，不能直接通过javascript监测到。这主要是为了避免根据读取到的期约状态，
以同步的方式处理期约对象。另外，期约的状态也不能被外部js代码修改。这与不能读取该状态的原因是
一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。

2.解决值、拒绝理由及期约用例

期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未
开始或正在执行中。“兑现”表示已经成功完成，而“拒绝”表示没有成功完成。

某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言
已经足够了。比如加入期约要想服务器发送一个http请求。请求返回200~299范围内的状态码就足以让期约
的状态变为兑现。类似的，如果请求返回的状态码不在200~299这个范围内，就会把这个期约状态切换为拒绝。

在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。
相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。比如，假设期约像服务器
发送了一个http请求并预定会返回一个json。如果请求返回范围在200~299的状态码，则足以让期约的状态
变为兑现。此时期约内部就可以接收到一个json字符串。类似地，如果请求返回的状态码不在200~299这个
范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个Error对象，包含着http状态码及相关
错误信息。

为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个
期约只要状态切换为拒绝，就会有一个私有的内部理由。无论是值还是理由都是包含原始值或兑现的不可修改
的引用。二者都是可选的，而且默认值为Undefined。在期约到达某个落定状态时执行的异步代码始终会收到
这个值或理由

3.通过执行函数控制期约状态

由于期约的状态是私有的，所有只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要
有两个职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个
函数参数实现的。着两个函数参数通常都命名为resolve()和reject()。调用resolve()会把状态切换为兑换，
调用reject()会把状态切换为拒绝。另外，调用reject()也会抛出错误。

let p1 = new Promise((resolve, reject) => resolve())
setTimeout(console.log, 0, p1)

let p2 = new Promise((resolve, reject) => reject())
setTimeout(console.log, 0, p2)

在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。
这里的关键在于，执行器函数时同步执行的。这是因为执行器函数是期约的初始化程序。

new Promise(() => setTimeout(console.log, 0, 'executor'))
setTimeout(console.log, 0, 'promise initialized')

//executor
//promise initialized

添加setTimeout可以推迟切换状态
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000))

setTimeout(console.log, 0, p)


let p = new Promise((resolve, reject) => {
  setTimeout(reject, 5000);
})

setTimeout(console.log, 0 , p)
setTimeout(console.log, 7000, p)

4.Promise.resolve();

期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用Promise.resolve()
静态方法，可以实例化一个解决的期约。

let p1 = new Promise((resolve, reject) => resolve())
let p2 = Promise.resolve();

这个解决的期约的值对应着传给Promise.resolve()的第一个参数。使用这个静态方法，实际上可以把任何值
都转换为一个期约。

setTimeout(console.log, 0, Promise.resolve())

setTimeout(console.log, 0, Promise.resolve(3))

//多余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6))

对于这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此，Promise.resolve()
可以说是一个幂等方法，如下所示：

let p = Promise.resolve(7)

setTimeout(console.log, 0, p === Promise.resolve(p))

setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p)))

这个幂等性会保留传入期约的状态

let p = new Promise(() => {})

setTimeout(console.log, 0, p)                         //Promise <pending>
setTimeout(console.log, 0, Promise.resolve(p))        //Promise <pending>

setTimeout(console.log, 0, p === Promise.resolve(p))  //true

注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合
于其的行为：

let p = Promise.resolve(new Error('foo'))
setTimeout(console.log, 0, p)
//Promise {<fulfilled>: Error: foo

5.Promise.reject()

与Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能
通过try/catch捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的

let p1 = new Promise((resolve, reject) => reject())
let p2 = Promise.reject();

这个拒绝的期约的理由就是传给Promise.reject()的第一个参数。这个参数也会传给后续拒绝处理程序。

let p = Promise.reject(3)
setTimeout(console.log, 0, p)     //Promise {<rejected>: 3}

p.then(null, e => setTimeout(console.log, 0, e))

关键在于，Promise.reject()并没有照搬Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个
期约会成为它返回的拒绝期约的理由。

setTimeout(console.log, 0, Promise.reject(Promise.resolve()))
//Uncaught (in promise) Promise {<fulfilled>: undefined}
//Promise {<rejected>: Promise}

6.同步/异步执行的二元性

Promise的设计很大程度上会导致一种完全不同于js的计算模式。

try{
  throw new Error('foo')
}catch(e){
  console.log(e)  
}
//Error: foo

try{
  Promise.reject(new Error('bar'))
}catch(e){
  console.log(e)
}
//Uncaught (in promise) Error: bar

第一个type/catch抛出并捕获了错误，第二个try/catch抛出错误却并没有捕获到。乍一看这可能有点违反
直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里的
同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正
的异步特性：他们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。

从前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。
因此，try/catch块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步
结构--更具体地说，就是期约的方法。


11.2.3 期约的实例方法

期约实例的方法是链接外部同步代码于内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理
期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才能执行的代码。

1.实现Thenable接口

在ECMAScript暴露的异步结构中，任何对象都有一个then()方法。这个方法被认为实现了Thenable接口。
下面的例子展示了是实现这一接口的最简单的类：
class MyThenable{
  then(){}
}

ECMAScript的Promise类型实现了Thenable接口。这个简化的接口跟typescript或其他包中的接口或类型定义
不同，他们都设定了Thenable接口更具有的形式。

2.Promise.prototype.then()

Promise.prototype.then()是为期约实现添加处理程序的主要方法。这个then()方法接收最多两个参数：
onResolved处理程序和onRejected处理程序。这两个参数都是可选的，如果提供的话则会在期约分别进入
“兑现”和“拒绝”状态时执行。

function onResolved(id){
  setTimeout(console.log, 0, id, 'resolved')
}

function onRejected(id){
  setTimeout(console.log, 0, id, 'rejected')
}

let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000))
let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000))

p1.then(() => onResolved('p1'),
        () => onRejected('p1'))
p2.then(() => onResolved('p2'),
        () => onRejected('p2'))

//p1 resolved
//p2 rejected

因为期约只能转换为最终状态依次，所以这两个操作一定时互斥的。

如前所述，两个处理程序参数都是可选的。而且，传给then()的任何非函数类型的参数都会被静默忽略。如果想
只提供onRejected参数，那就要在onResolved参数的位置上传入undefined.这样有助于避免在内存中创建多余
的兑现，对期待函数参数的类型系统也是一个交代。

function onResolved(id){
  setTimeout(console.log, 0, id, 'resolved')
}

function onRejected(id){
  setTimeout(console.log, 0, id, 'rejected')
}

let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000))
let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000))

//非函数处理程序会被静默忽略，不推荐
p1.then('gobbletygook')

//不传onResolved处理程序的规范写法
p2.then(null, () => onRejected('p2'))

Promise.prototype.then()方法返回一个新的期约实例

let p1 = new Promise(() => {})
let p2 = p1.then();             //then方法返回一个新的期约实例
setTimeout(console.log, 0, p1)
setTimeout(console.log, 0, p2)
setTimeout(console.log, 0, p1 === p2)

//Promise {<pending>}
//Promise {<pending>}
//false

这个新期约实例基于onResolved处理程序的返回值构建。换句话说，该处理程序的返回值会通过Promise.resolve()
包装来生成新期约。如果没有提供这个处理程序，则Promise.resolve()就会包装上一个期约解决之后的值
如果没有显式的返回语句，则Promise.resolve()会包装默认的返回值Undefined

let p1 = Promise.resolve('foo')
//若调用then()时不传处理程序，则原样向后传
let p2 = p1.then()

setTimeout(console.log, 0, p2)
//Promise {<fulfilled>: "foo"}

let p3 = p1.then(() => undefined)
let p4 = p1.then(() => {})
let p5 = p1.then(() => Promise.resolve())

setTimeout(console.log, 0, p3)    //Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p4)    //Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p5)    //Promise {<fulfilled>: undefined}

如果有显式的返回值，则Promise.resolve()会包装这个值

let p6 = p1.then(() => 'bar')
let p7 = p1.then(() => Promise.resolve('bar'))

setTimeout(console.log, 0, p6)    //Promise {<fulfilled>: "bar"}
setTimeout(console.log, 0, p7)    //Promise {<fulfilled>: "bar"}

Promise.resolve()保留返回的期约

let p8 = p1.then(() => new Promise(() => {}))
let p9 = p1.then(() => Promise.reject())

setTimeout(console.log, 0, p8)    //Promise {<pending>}
setTimeout(console.log, 0, p9)    //Promise {<rejected>: undefined}

抛出异常会返回拒绝的期约

let p10 = p1.then(() => {throw 'baz'})
setTimeout(console.log, 0, p10)   //Promise {<rejected>: "baz"}

注意：返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中

let p11 = p1.then(() => Error('qux'))
setTimeout(console.log, 0, p11)     //Promise {<fulfilled>: Error: qux

onRejected处理程序也与之类似：onRejected处理程序返回的值也会被Promise.resolve()包装。乍一看
有点违反直觉，但想一想，onRejected处理程序的任务不就是捕获异常错误吗。因此，拒绝处理程序在捕获
错误后不抛出异常是符合期约的行为，应该返回一个解决期约。


let p1 = Promise.reject('foo')
//若调用then()时不传处理程序，则原样向后传
let p2 = p1.then()  //Uncaught (in promise) foo

setTimeout(console.log, 0, p2)
//Promise {<rejected>: "foo"}

let p3 = p1.then(null, () => undefined)
let p4 = p1.then(null, () => {})
let p5 = p1.then(null, () => Promise.resolve())

setTimeout(console.log, 0, p3)    //Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p4)    //Promise {<fulfilled>: undefined}
setTimeout(console.log, 0, p5)    //Promise {<fulfilled>: undefined}

如果有显式的返回值，则Promise.resolve()会包装这个值

let p6 = p1.then(null, () => 'bar')
let p7 = p1.then(null, () => Promise.resolve('bar'))

setTimeout(console.log, 0, p6)    //Promise {<fulfilled>: "bar"}
setTimeout(console.log, 0, p7)    //Promise {<fulfilled>: "bar"}

Promise.resolve()保留返回的期约

let p8 = p1.then(null, () => new Promise(() => {}))
let p9 = p1.then(null, () => Promise.reject())
//Uncaught (in promise) undefined

setTimeout(console.log, 0, p8)    //Promise {<pending>}
setTimeout(console.log, 0, p9)    //Promise {<rejected>: undefined}

抛出异常会返回拒绝的期约

let p10 = p1.then(null, () => {throw 'baz'})
//Uncaught (in promise) baz
setTimeout(console.log, 0, p10)   //Promise {<rejected>: "baz"}

3.Promise.prototype.catch()

Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接收一个参数：onRejected
处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用Promise.prototype.then(null, 
onRejected)

下面的代码展示了这两种同样的情况：

let p = Promise.reject();
let onRejected = function(e){
  setTimeout(console.log, 0, 'rejected')
}

p.then(null, onRejected)    //rejected
p.catch(onRejected)         //rejected

Promise.prototype.catch()返回一个新的期约实例：

let p1 = new Promise(() => {})
let p2 = p1.catch()

setTimeout(console.log, 0, p1)          //Promise {<pending>}
setTimeout(console.log, 0, p2)          //Promise {<pending>}
setTimeout(console.log, 0, p1 === p2)   //false

返回新期约实例方面，Promise.prototype.catch()的行为与Promise.prototype.then()的onRejected
处理程序是一样的。

4.Promise.prototype.finally()

Promise.prototype.finally()方法用于给期约添加onFinally处理程序，这个处理程序在期约转换为
解决或拒绝状态时都会执行。这个方法可以避免onResolved和onRejected处理程序中出现冗余代码。但
onFinally处理程序没办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。

let p1 = Promise.resolve()
let p2 = Promise.reject()

let onFinally = function(){
  setTimeout(console.log, 0, 'Finally!')
}

p1.finally(onFinally)   //Finally!
p2.finally(onFinally)   //Finally!
//Uncaught (in promise) undefined

Promise.prototype.finally()方法返回一个新的期约实例：

let p1 = new Promise(() => {})
let p2 = p1.finally()

setTimeout(console.log, 0, p1)
setTimeout(console.log, 0, p2)
setTimeout(console.log, 0, p1 === p2)

这个期约实例不同于then()或catch()方式返回的实例。因为onFinally被设计为一个状态无关的方法，
所以在大多数情况下它将表现为父期约的传递。对已解决状态和被拒绝状态都是如此。

let p1 = Promise.resolve('foo')

let p2 = p1.finally()
let p3 = p1.finally(() => undefined)
let p4 = p1.finally(() => {})
let p5 = p1.finally(() => Promise.resolve())
let p6 = p1.finally(() => 'bar')
let p7 = p1.finally(() => Promise.resolve('bar'))
let p8 = p1.finally(() => Error('qux'))

setTimeout(console.log, 0, p2)    //Promise {<fulfilled>: "foo"}
setTimeout(console.log, 0, p3)    //Promise {<fulfilled>: "foo"}
setTimeout(console.log, 0, p4)    //Promise {<fulfilled>: "foo"}
setTimeout(console.log, 0, p5)    //Promise {<fulfilled>: "foo"}
setTimeout(console.log, 0, p7)    //Promise {<fulfilled>: "foo"}
setTimeout(console.log, 0, p8)    //Promise {<fulfilled>: "foo"}

如果返回的是一个待定期约，或者onFinally处理程序抛出异常(显式抛出或返回了一个拒绝期约)，则会
返回相应的期约（待定或拒绝）

