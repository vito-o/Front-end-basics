期约与异步函数

·异步函数
·期约
·异步函数

ECMAScript6新增了正式的Promise(期约)引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了
async和await关键字定义异步函数的机制。

注意： 本章实例将大量使用异步日志输出的方式setTimeout(console.log, 0, ...params)，旨在演示执行
顺序及其他异步行为。异步输出的内容看起来虽然像是同步输出的，但实际上是异步打印的。这样可以让期约
等返回的值达到其最终状态。

此外，浏览器控制台的输出经常能打印出javascript允许中无法获取的对象信息（比如期约的状态）。这个特性
在示例中广泛使用，以便辅助读者理解相关概念。

11.1 异步编程

同步行为和异步行为的对立统一是计算机的一个基础概念。特别是在javascript这种单线程事件循环中，同步
操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待
其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么
任何时候都可以使用。

11.1.1 同步与异步

同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照他们出现的顺序来执行，而每条指令执行后
也能立即获得存储在系统本地（入寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意
位置是的状态（比如变量的值）。
let x = 3;
x = x + 4;
在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到
最后一条指令执行完毕，存储在x的值就立即可以使用.

这两行javascript代码对应的低级指令（从javascript到x86）并不难想象。首先，操作系统会在栈内存上分配
一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令
都是在单个线程中按照顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。

相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制
进程等待一个长事件的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如
像远程服务器发送请求并等待响应，那么就会出现长事件的等待。

let x = 3;
setTimeout(() => x = x + 4, 100)

这段程序最终与同步代码执行的认为一样，都是把两个数加在一起，但这一次执行线程不知道x值何时会改变。
因为这取决于回调何时从消息队列出列并执行。

异步代码不容易推断。虽然这个例子对应的低级代码最终跟前面的例子没什么区别，但第二个指令块（加操作
及赋值操作）是由系统计时器触发的，这会生成一个入队执行的中断。到底什么时候会触发这个中断，这对
javascript运行时来说是一个黑盒，因此实际上无法预知（尽管可以保证这发生在当前线程的同步代码执行之
后，否则回调都没有机会出列被执行）。无论如何，在排定回调以后基本没办法知道系统状态何时变化。

为了让后续代码能够使用x，异步执行的函数需要在更新x的值以后通知其他代码。如果程序不需要这个值，那么
就只管继续执行，不必等待这个结果了。

设计一个能够知道x什么时候可以读取的系统是非常难的。javascript在实现这样一个系统的过程中也经历了
几次迭代。

11.1.2 以往的异步编程模式

异步行为是javascript的基础，但以前的实现不理想。早期的javascript中，只支持定义回调函数来表明异步
操作完成。串联多个异步操作时常见的问题。通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。

假设有以下异步函数，使用setTimeout在一秒钟之后执行某些操作：
function double(value){
  setTimeout(() => setTimeout(console.log, 0, value * 2), 1000)
}
double(3)

这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。setTimeout可以定义一个在指定时间之后
会被调用的回调函数。对这个例子而言，1000毫秒之后，javascript运行时会把回调函数推到自己的消息队列
上去等待执行。推到队列之后，回调什么时候出列被执行对javascript代码就完全不可见了。还有一点，double()
函数在setTimeout成功调度异步操作之后会立即退出。

1.异步返回值
