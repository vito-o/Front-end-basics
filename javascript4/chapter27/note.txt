第27章 工作者线程

本章内容
·工作者线程简介
·使用专门的工作者线程执行后台任务
·使用共享的工作者线程
·通过服务工作者线程管理请求


前端开发者常说，js时单线程的。这种说法虽然有些简单，但描述了js在浏览器中的一般行为。

单线程就意味着不能像多线程语言那样把工作委托给独立的线程或进程去做。js的单线程可以包装它与不同浏览器
API兼容。假如js可以多线程执行并发更高，那么像DOM这样的API就会出现问题。因此，POSIX线程或java的
Thread等创痛并发结构都不适合js

而这也正是工作者线程的价值坐在：允许把主线程的工作转嫁给独立的实体，而不会改变现有的单线程模式。虽然
本章要介绍的各种工作者线程有不同的形式和功能，但他们的共同的特点都是独立于js的主执行环境。

27.1 工作者线程简介

js环境实际上是运行在托管操作系统中的虚拟环境。在浏览器中每打开一个页面，就会分配一个它自己的环境。
这样，每个页面都有自己的内存、事件循环、DOM，等。每个页面就相当于一个沙盒，不会干扰其他页面。对于
浏览器来说，同时管理多个环境是非常简单的，因为所有这些环境都是并行执行的。

使用工作者线程，浏览器可以在原始页面环境之外再分配一个完全独立的二级子环境。这个子环境不能与依赖
单线程交互API操作（如DOM），单可以与父环境并行执行代码。

27.1.1 工作者线程与线程

作为介绍，通常需要将工作者线程与执行线程进行比较。在许多方面，这是一个恰当的比较，因为工作者线程
和线程确实有很多共同之处。

·工作者线程是以实际线程实现的。例如，Blink浏览器引擎实现工作者线程的WorkerThread就对应着底层线程
·工作者线程并行执行。虽然页面和工作者线程都是单线程js环境，每个环境中的指令则可以并行执行。
·工作者线程可以共享某些内存。工作者线程能够使用SharedArrayBuffer在多个环境间共享内容。虽然线程会
使用锁实现并发控制，但js使用Atomics接口实现并发控制。
工作者线程与线程有很多类似之处，但也有重要的区别。

·工作者线程不共享全部内存。在传统线程模型中，多线程有能力读写共享内存空间。除了SharedArrayBuffer外，
从工作者线程进出的数据需要复制或转移
·工作者线程不一定在同一个进程里。通常，一个进程可以在内部产生多个线程。根据浏览器引擎的实现，工作者
线程可能与页面属于同一进程，也可能不属于。例如，Chrome的Blink引擎对共享工作者线程和服务工作者线程
使用独立的进程。
·创建工作者线程的开销更大。工作者线程有自己独立的事件循环、全局对象、事件处理此程序和其他js环境必须
的特性。创建这些结构的代价不容忽视。
无论形式还是功能，工作者线程都不是用于代替线程的。

27.1.2 工作者线程的类型

web工作者线程规范中定义了三种主要的工作者线程：专用工作者线程、共享工作者线程和服务工作者线程。
现代浏览器都支持这些工作者线程。

1.专用工作者线程

专用工作者线程，通常简称为工作者线程、Web Worker或Worker，是一种实用的工具，可以让脚本单独创建
一个js线程，以执行委托的任务。专用工作者线程，顾名思义，只能被创建它的页面使用。

2.共享工作者线程

共享工作者线程与专用工作者线程非常相似。主要区别时共享工作者线程可以被多个不同的上下文使用，包括
不同的页面。任何与创建共享工作者线程的脚本同源的脚本，都可以向通向工作者线程发送消息或从中接收消息。

3.服务工作者线程

服务工作者线程与专用工作者线程和共享工作者线程截然不同。它的主要用途是拦截、重定向和修改页面发出的
请求，充当网络请求的仲裁者的角色。

27.1.3 WorkerGlobalScope

在网页上，window对象可以向运行在其中的脚本暴露各种全局变量。在工作者线程内部，没用window的概念。
这里的全局对象是WorkerGlobalScope的实例，通过self关键字暴露出来。

1.WorkerGlobalScope属性和方法

self上可用的属性是window对象上属性的严格子集。其中有些属性会返回特定于工作者线程的版本。

·navigator：返回于工作者线程关联的WorkerNavigator
·self：返回WorkerGlobalScope对象
·location：返回与工作者线程关联的WorkerLocation
·performance：返回（只包含特定属性和方法的）Performance对象
·console：返回与工作者线程关联的console对象；对API没有限制。
·caches：返回与工作者关联的CacheStorage对象；对API没有限制。
·indexDB：返回IDBFactory对象
·isSecureContext：返回布尔值，表示工作者线程上下文是否安全
·origin：返回WorkerGlobalScope的源

类似地，self对象上暴露的一些方法也是window上方法的子集。这些self上的方法也与window上对应的方法
操作一样。

·atob()
·btoa()
·clearInterval()
·clearTimeout()
·createImageBitmap()
·fetch()
·setInterval()
·setTimeout()

WorkerGlobalScope还增加了新的全局方法importScripts()，只在工作者线程内可以用。

2.WorkerGlobalScope的子类

实际上并不是所有地方都实现了WorkerGlobalScope。每种类型的工作者线程都使用了子集特定的全局对象，
这些继承自WorkerGlobalScope。

·专用工作者线程使用DedicatedWorkerGlobalScope。
·共享工作者线程使用SharedWorkerGlobalScope。
·服务工作者线程使用ServiceWorkerGlobalScope。

27.2 专用工作者线程

专用工作者线程是最简单的web工作者线程，网页中的脚本可用创建专用工作者线程来执行在页面线程之外的其他
任务。这样的线程可用于父页面交换信息、发送网络请求、执行文件输入/输出、进行密集计算、处理大量数据，
以及实现其他不适合在页面执行线程里做的任务（否则会导致页面响应迟钝）

注意：在使用工作者线程时，脚本在哪里执行、在哪里加载时非常重要的概念。除非另有说明，否则本章假定main.js
是从https://example.com域的根路径加载并执行的顶级脚本。

27.2.1 专用工作者线程的基本概念

可用把专用工作者线程称为后台脚本（background script）。javascript线程的各个方面，包括生命周期管理、
代码路径和输入/输出，都由初始化线程时提供的脚本来控制。该脚本也可用再请求其他脚本，但一个线程总是从
一个脚本源开始。

1.创建专用工作者线程

创建专用工作者线程最常见的方式是加载js文件。把文件路径提供给Worker构造函数，然后构造函数再在后台
异步加载脚本并实例化工作者线程。传给构造函数的文件路径可用是多种形式。

下面的代码演示了如何创建空的专用工作者线程：

//emptyWorker.js
//空的js工作者线程文件

//main.js
console.log(location.href)
const worker = new Worker(location.href + 'demo1/' + 'emptyWorker.js')
console.log(worker)

这个例子非常简单，但涉及几个基本概念。
·emptyWorker.js文件是从绝对路径加载的。根据应用程序的结构，使用绝对URL经常是多余的。
·这个文件是在后台加载的，工作者线程的初始化完全独立于main.js
·工作者线程本身存在于一个独立的js环境中，因此main.js必须以Worker对象为代理实现于工作者线程通信。
在上面的例子中，该对象被赋值给了worker变量。
·虽然响应的工作者线程可能换不存在，但该Worker对象已在原始环境中可用了。

2.工作者线程安全限制

工作者线程的脚本文件只能与父页面相同的源记载。从其他源加载工作者线程的脚本文件会导致错误。

注意：不能使用非同源脚本创建工作者线程，并不影响执行执行其他源的脚本。再工作者线程内部，使用
importScripts()可用加载其他源的脚本。

基于加载脚本创建的工作者线程不受文档的内容安全策略限制，因为工作者线程在与父文档不同的上下文中运行。
不过，如果工作者线程加载的脚本带有全局唯一标识符（与加载自一个二进制大文件一样），就会受父文档内容
安全策略的限制。


3.使用Worker对象

注意：要管理好使用Worker()创建的每个Worker对象。在终止工作者线程之前，它不会被垃圾回收，也不能通过
编程方式恢复对之前Worker对象的引用。

Worker对象支持下列时间处理程序：
·onerror：在工作者线程中发生ErrorEvent类型的错误事件时会调用指定给该属性的处理程序。
    -该事件会在工作者线程中抛出错误时发生
    -该事件也可以通过worker.addEventListener('error', handler)的形式处理。
·onmessage：在工作者线程中发生MessageEvent类型的消息事件时会调用指定给该属性的处理程序。
    -该事件会在工作者线程向父上下文发送消息时发生
    -该事件也可以通过使用worker.addEventListener('message', handler)处理。
·onmessageerror：在工作者线程中发生MessageEvent类型的错误事件时会调用指定给该属性的处理程序。
    -该事件会在工作者线程收到无法发序列化的消息时发生。
    -该事件也可以通过使用worker.addEventListener('messageerror', handler)处理
Worker对象还支持下列方法。

·postMessage():用于通过异步消息事件向工作者线程发送信息
·terminate()：用于立即终止工作者线程。没有为工作者线程提供清理的机会。脚本会突然停止。

4.DedicatedWorkerGlobalScope

在专用工作者线程内部，全局作用域是DedicatedWorkerGlobalScope的实例。因为这继承自WorkerGlobalScope，
所以包含它的所有属性和方法。工作者线程可以通过self关键字访问该全局作用域。

顶级脚本和工作者线程中的console对象都将写入浏览器看控制台，这对于调试非常有用。因为工作者线程具有
不可忽略的启动延迟，所以即使Worker对象存在，工作者线程的日志也会在主线程的日志之后打印出来。

注意：这里两个独立的js线程都向一个console对象发消息，该对象随后将消息序列化并在刘阿龙年起控制台打印
出来。浏览器从两个不同的js线程收到消息，并按照子集认为合适的顺序输出这些消息。为此，在多线程应用程序
中使用日志确定操作顺序时必须要当心。

DedicatedWorkerGlobalScope在WorkerGlobalScope基础上增加了一下属性和方法。
·name：可以提供给Worker构造函数的一个可选的字符串标识符
·postMessage()：与worker.postMessage()对应的方法，用于从工作者线程内部向父上下文发送消息。
·close()：与worker.terminate()对应的方法，用于立即终止工作者线程。没有为工作者线程提供清理的机会，
脚本会突然停止。
·importScripts()：用于向工作者线程中导入任意数量的脚本。

27.2.2 专用工作者线程与隐式MessagePosts

专用工作者线程与Worker对象和DedicatedWorkerGlobalScope与MessagePorts有一些相同接口处理程序和
方法：onmessage、onmessageerror、close()和postMessage()。这不是偶然的，因为专用工作者线程隐式
使用了MessagePorts在两个上下文之间通信。

父上下文中的Worker对象和SedicatedWorkerGlobalScope实际上MessagePort，并在子集的接口中分别暴露了
响应的处理程序和方法。换句话说，消息还时通过MessagePort发送，只是没有直接使用MessagePort而已。

也有不一致的地方，比如start()和close()约定。专用工作者线程会自动发送排队的消息，因此start()也就
没有必要了。另外，close()在专用工作者线程的上下文中没有意义，因为这样关闭MessagePort会使工作者线程
孤立。因此，在工作者线程内部调用close()（或在外部调用terminate()）不仅会关闭MessagePort，也会
终止线程。 

27.2.3 专用工作者线程的生命周期

调用Worker()构造函数是一个专用工作者线程的起点。调用之后，他会初始化对工作者线程脚本的请求，并把
Worker对象返回给父上下文。虽然父上下文中可以立即使用这个Worker对象，但与之关联的工作者线程可能还
没有创建，因为存在请求脚本的网络延迟和初始化延迟。

一般来说，专用工作者线程可以非正式区分为处于下列三个状态：初始化(initializing)、活动(active)和
终止(terminated)。这几个状态对其他上下文是不可见的。虽然Worker对象可能会存在于父上下文中，但也无法
通过它确定工作者线程当前是处理初始化、活动还是终止状态。换句话说，与活动的专用工作者线程关联的Worker
对象和与终止的专用工作者线程关联的Worker对象无法分别。

初始化时，虽然工作者线程脚本尚未执行，但可以先把要发送给工作者线程的消息加入队列。这些消息会等待工作
着线程的状态变为活动，再吧消息添加到它的消息队列。下面的代码演示了这个过程。

创建之后，专用工作者线程就会伴随页面的整个生命期而存在，除非自我终止（self.close()）或者通过外部
终止(worker.terminate())。即使线程脚本已运行完成，线程的环境仍会存在。只要工作者线程仍存在，
与之关联的Worker对象就不会被当初垃圾收集掉。

自我终止和外部终止最终都会执行相同的工作者线程终止历程。

虽然调用了close()，但显然工作者线的执行并没有立即终止。close()在这里会通知工作者线程取消事件循环
中的所有任务，并阻止继续添加新任务。这也是为什么'baz'没有打印出来的原因。工作者线程不需要执行同步
停止，因此在父上下文的事件循环中处理的'bar'仍会打印出来。

一旦调用了terminate()，工作者线程的消息队列就会被清理并锁住，

注意close()和terminate()是幂等操作，多次调用没有问题。

在整个什么周期中，一个专用工作者线程只会关联一个网页（Web工作者线程规范称其为一个文档）。除非明确
终止，否则只要关联存在，专用工作者线程就会存在。如果浏览器离开网页（通过导航或关闭标签页或关闭窗口）
它会将于其关联的工作者线程标记为终止，他们的执行也会立即停止。


27.2.4 配置Worker选项

Worker()构造函数允许将可选的配置对象作为第二个参数。该配置对象支持下列属性。

·name：可以在工作者线程中通过self.name读取到的字符串标识符
·type：表示加载脚本的允许方式，可以是'classic'或'module'。'classic'将脚本作为常规脚本来执行，
'module'将脚本作为模块来执行。

·credentials：在type为'module'时，指定如何获取与传输 凭证数据相关的工作者线程模块脚本。值可以是
'omit'、'same-origin'或'include'。这些选项与fetch()的凭证选项相同。在type为'classic'时，默认
'omit'。

27.2.5 在js行内创建工作者线程

工作者线程需要基于脚本文件来创建，但着并不意味着该脚本必须是远程资源。专用工作者线程也可以通过Blob
对象URL在行内脚本创建。这样可以更快速地初始化工作者线程，因为没有网络延迟。

例：

//创建要执行的js代码字符串
const workerScript = `
    self.onmessage = ({data}) => console.log(data)
`

//基于脚本字符串生成Blob对象
const workerScriptBlob = new Blob([workerScript])

//基于Blob实例创建对象URL
const workerScriptBlobUrl = URL.createObjectURL(workerScriptBlob)

//基于对象URL创建工作者线程
const worker = new Worker(workerScriptBlobUrl)

worker.postMessage('blob worker script')

这个例子中，通过脚本字符串创建了Blob，然后又通过Blob创建了对象URL，最后把对象URL传给了Worker()构造
函数。该构造函数同样传教了专用工作者线程。

如果把所有代码写在一块，可以浓缩为这样

const worker = new Worker(URL.createObjectURL(new Blob([`self.onmessage = ({data}) => console.log(data)`])))


工作者线程也可以利用函数序列化来初始化行内脚本。这是因为函数的toString()方法返回函数代码的字符串，
而函数可以在父上下文中定义但在子上下文中执行。
例：
function fibonacci(n) {
    return n < 1 ? 0
        : n <= 2 ? 1
        : fibonacci(n - 1) + fibonacci(n - 2)
}

const workerScript = `
    self.postMessage(
        (${fibonacci.toString()})(9)
    )
`

const worker = new Worker(URL.createObjectURL(new Blob([workerScript])))

worker.onmessage = ({data}) => console.log(data)

该函数作为IIFE调用并传递参数，结构被发送回主线程。虽然计算斐波那契数列比较耗时，但所有计算都会委托
到工作者线程，因此并不会影响父上下文的性能。

注意：像这样序列化函数有一个前提，就是函数体内不能使用通过闭包获得的引用，也包括全局变量，比如
window，因为这些引用在工作者线程中执行时回出错。

27.2.6 在工作者线程中动态执行脚本

工作者线程中的脚本并发铁板一块，而是可以使用importScripts()方法通过编程方式加载和执行任意脚本。
该方法可用于全局Worker对象。这个方法会加载脚本并按照加载顺序同步执行。
例：demo8

importScripts()方法可以接收任意数量的脚本作为参数。浏览器下载他们的属性没有限制，但执行则会严格
按照他们的参数列表的顺序进行。因此，下面的代码与前面的效果一样：

console.log('importing scripts')

importScripts('./scriptA.js', './scriptB.js')

console.log('scripts imported')


脚本加载收到常规CORS的限制，但在工作者线程内部可以请求来自任何源的脚本。这里的脚本导入策略类似于使用
生成的<script>标签动态加载脚本。在这种情况下，所有导入的脚本也会共享作用域。

main.js

const worker = new Worker('./worker.js', {name: 'foo'})

scriptA.js

console.log(`scriptA executes in ${self.name} with ${globalToken}`)

scriptB.js

console.log(`scriptB executes in ${self.name} with ${globalToken}`)

worker.js

const globalToken = 'bar'
