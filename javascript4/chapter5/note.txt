基本引用类型

引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构
经常被人错误地称作“类”。虽然从技术上讲javascript是一门面向对象语言，但ECMAScript缺少传统的面向对象
编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为他们描述了自己的对象
应有的属性和方法。

注意 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”

对象被认为是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。
构造函数就是用来创建新对象的函数，比如下面这行代码：

let now = new Date();

这行代码创建了引用类型date的一个新实例，并将它保存在变量now中。Date()在这里就是构造函数，它负责
创建一个只有默认属性和方法的简单对象。ECMAScript提供了很多像Date这样的原生引用类型，帮助开发者
实现常见的任务。

注意：函数也是引用类型

5.1 Date

ECMAScript的Date类型参考了java早期版本中的java.util.Date。为此，Date类型将日期保存为自协调世界
时（UTC, Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种
存储格式，Date类型可以精确标识1970年1月1日之前及之后285616年的日期。

要创建日期对象，就是用new操作符来调用Date构造函数：
let now = ew Date();

5.2 RegExp
 
ECMAScript通过RegExp类型支持正则表达式。正则表达式应用类似Perl的简介语法来创建：
let expression = /pattern/flags;

这个正则表达式的pattern(模式)可以是任何简单或负责的正则表达式，包括字符类、限定符、分组、向前查找
和反向引用。每个正则表达式可以带零个或多个flags（标记），用于控制正则表达式的行为。下面给出了表示
匹配模式的标记。
g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束
i：不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写。
m：多行模式，表示查找到一行文本末尾时会继续查找
y：粘附模式，表示只查找从lastIndex开始及之后的字符串
u：Unicode模式，启用Unicode匹配
s：dotAll模式，表示元字符。匹配任何字符（包括\n或\r）
使用不同模式和标记可以创建出各种正则表达式，

//匹配字符串中的所有'at'
let pattern1 = /at/g;

//匹配第一个bat或者cat,忽略大小写
let pattern2 = /[bc]at/i;

//匹配所有以'at'结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;

与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括：
( ) [ ] { } \ ^ & | ? * + .
元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，必须使用反斜杠来转义。

//匹配第一个bat或cat，忽略大小写
let pattern1 = /[bc]at/i;

//匹配第一个[bc]at,忽略大小写
let pattern2 = /\[bc\]at/i;

//匹配所有以at结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;

//匹配所有.at，忽略大小写
let pattern4 = /\.at/gi;

这里的pattern1匹配bat或cat，不区分大小写。要直接匹配[bc]at，左右中括号必须像pattern2中那样使用
反斜杠转义。在pattern3中，点号表示'at'前面的任意字符都可以匹配。如果像匹配'.at'，那么要像pattern4
中那样对点好进行转义。

前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用RegExp构造函数来创建，它接收
两个参数：模式字符串和（可选的）标记字符串。任何使用字面量定义的正则表达式也可以通过构造函数来创建
//匹配第一个bat或cat，忽略大小写
let pattern1 = /[bc]at/i

let pattern2 = new RegExp('[bc]at', 'i')

这里pattern1和pattern2是等效的正则表达式。注意，RegExp构造函数的两个参数都是字符串。因为RegExp的模式
参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n(\转义后的
字符串是\\，在正则表达式字符串中则要写成\\\\)。下表展示了几个正则表达式的字面量形式，以及使用RegExp构造
函数创建时对应的模式字符串。

      字面量模式                对应的字符串
    /\[bc\]at/                  "\\[bc\\]at"
    /\.at/                      "\\.at"
    /name\/age/                 "name\\/age"
    /\d.\d{1,2}/                "\\d\.\\d{1,2}"
    /\w\\hello\\123/            "\\w\\\\hello\\\\123"

此外，使用RegExp也可以基于已有的正则表达式实例，并可选择性地修改他们的标记
let re1 = /cat/gi
console.log(re1)
let re2 = new RegExp(re1);
console.log(re2)
let re3 = new RegExp(re1, 'i')
console.log(re3)

5.2.1 RegExp 实例属性

每个RegExp实例都有下列属性，提供有关模式的各方面信息
global: 布尔值，表示是否设置了g标记
ignoreCase:布尔值，表示是否设置了i标记
unicode：布尔值，表示是否设置了u标记
sticky：布尔值，表示是否设置了y标记
lastIndex： 整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
multiline：布尔值，表示是否设置了m标记
dotAll：布尔值，表示是否设置了s标记
source：正则表达式的字面量字符串（不是传给构造函数的模式字符串）没有开头和结尾的斜杠
flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（每有前后斜杠）

通过这些属性可以全面了解正则表达式的信息，不过实际开发中用得并不多，因为模式声明中包含这些信息
let pattern1 = /\[bc\]at/i;

console.log(pattern1.global); //false
console.log(pattern1.ignoreCase); //true
console.log(pattern1.multiline); //false
console.log(pattern1.lastIndex); //0
console.log(pattern1.source); //'\[bc\]at\'
console.log(pattern1.flags); //i

let pattern2 = new RegExp('\\[bc\\]at', 'i')
console.log(pattern2.global); //false
console.log(pattern2.ignoreCase); //true
console.log(pattern2.multiline); //false
console.log(pattern2.lastIndex); //0
console.log(pattern2.source); //'\[bc\]at\'
console.log(pattern2.flags); //i

注意，虽然第一个模式是通过字面量创建得，第二个模式是通过RegExp构造函数创建得，但两个模式的ource和flags
属性是相同的。source和flags属性返回的是规范化之后可以在字面量中使用的形式

5.2.2 RegExp实例方法

RegExp实例的主要方法是exec()，主要用于配合捕获组使用。这个方法只接受一个参数，即要应用模式的字符串
如果找到了匹配项，则返回包含第一个匹配信息的数组；如果每找到匹配项，则返回null。返回的数组虽然是Array
的实例，担包含两个额外的属性：index和input。index是字符串中匹配模式的起始位置，input是要查找的字符串。
这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有
捕获组，则数组只包含一个元素。

let text = 'mom and dad and baby'
let pattern = /mom( and dad( and baby)?)?/gi;
let matches = pattern.exec(text);

//(3) ["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]
这个例子中，模式包含两个匹配组：内部的匹配项' and baby'，以及外部' and dad' 或 'and dad and baby'
调用exec()后找到了一个匹配项。因为整个字符串匹配模式，所以matches数组的inde属性就是0.数组的第一个
元素是匹配的整个字符串，第二个元素是匹配第一个捕获组的字符串，第三个元素是匹配第二个捕获组的字符串

如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个
字符串调用多少次execc()，也只会返回第一个匹配的信息.

let text = 'cat, bat, sat, fat'
let pattern = /.at/;
let matches = pattern.exec(text);

console.log(matches.index); //0
console.log(matches[0]);    //cat
console.log(pattern.lastIndex); //0

let matches = pattern.exec(text);
console.log(matches.index); //0
console.log(matches[0]);    //cat
console.log(pattern.lastIndex); //0

上面例子中的模式没有设置全局标记，因此调用exec()只返回第一个匹配项('cat')。lastIndex在非全局模式
下始终不变。

如果在这个模式上设置了g标记，则每次调用exec()都会在字符串中项前搜索下一个匹配项，如下所示；
let text = 'cat, bat, sat, fat'
let pattern = /.at/g;
let matches = pattern.exec(text);
//["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]
console.log(matches.index); //0
console.log(matches[0]);    //cat
console.log(pattern.lastIndex); //3

let matches1 = pattern.exec(text);
console.log(matches1.index); //5
console.log(matches1[0]);    //bat
console.log(pattern.lastIndex); //8


这个模式设置了全局标记，因此每次调用exec()都会返回字符串中的洗一个匹配项，直到搜索到字符串末尾。
注意面模式的lastIndex属性每次都会变化。在全局匹配模式下，每次调用exec()都会更新lastIndex值，以
反映上次匹配的最后一个字符的索引。

如果模式设置了粘附标记y，则每次调用exec()就只会在lastIndex的位置上寻找匹配项。粘附标记覆盖全局标记
let text = 'cat, bat, sat, fat';
let pattern = /.at/y;

let matches = pattern.exec(text);
console.log(matches.index)    //0
console.log(matches[0])       //cat
console.log(pattern.lastIndex)//3

//以索引3对应的字符开头找不到匹配项，因此exec()返回null
//exec()没有找到匹配项，于是将lastIndex设置为0
matches = pattern.exec(text);
console.log(matches)            //null
console.log(pattern.lastIndex)  //0

pattern.lastIndex = 5;
matches = pattern.exec(text); 
console.log(matches.index)//5
console.log(matches[0])   //bat
console.log(pattern.lastIndex) //8


正则表达式的另一个方法是test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回true，
否则返回false。这个方法只适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。

test()经常用在if语句中；
let text = '000-00-0000'
let pattern = /\d{3}-\d{2}-\d{4}/
if(pattern.test(text)){
  console.log('the pattern was matched.')
}

无论正则表达式是怎么创建的，继承的方法toLocaleString()和toString()都返回正则表达式的字面量表示.
let pattern = new RegExp('\\[bc\\]at', 'gi')
console.log(pattern.toString())       //  /\[bc\]at/gi
console.log(pattern.toLocaleString()) //  /\[bc\]at/gi
这里的模式是通过RegExp构造函数创建的，但toLocaleString()和toString()返回的都是其字面量的形式。

注意： 正则表达式的valueOf()方法返回正则表达式本身。

5.2.3 RegExp构造函数属性