第十章 函数

本章内容
·函数表达式、函数声明及箭头函数
·模式参数及扩展操作符
·使用函数实现递归
·使用闭包实现私有变量

函数实际上是对象。
每个函数都是Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。
因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。

函数通常以
函数声明的方式定义：
function sum(num1, num2){
  return num1 + num2;
}

函数表达式
let sum = function(num1, num2){
  return num1 + num2;
}

函数表达式与函数声明几乎是等价的。

还有一种定义函数的方式与函数表达式很像，叫做“箭头函数”(arrow function)

let sum = (num1, num2) => {
  return num1 + num2
}

最后一种定义函数的方式是使用Function构造函数。这个构造函数接收 任意多个字符串参数，最后一个参数
始终会被当成函数体，而之前的参数都是新函数的参数。
let sum = new Function('num1', 'num2', 'return num1 + num2'); //不推荐

不推荐原因：
这段代码会被解释两次
第一次：是将它作为常规ECMAScript代码，
第二次：是解释传给构造函数的字符串。
很影响性能。

不过，把函数想象为对象，把函数名想象为指针式很重要的。

注意：这几种实例化函数对象的方式之间存在微妙但重要的差别。
      无论如何，通过其中任何一种方式都可以创建函数。

10.1 箭头函数

ECMAScript6新增。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为式相同的。
任何可以使用函数表达式的地方，都可以使用箭头函数。

let arrowSum = (a, b) => {
  return a + b;
}

let functionExpressionSum = function(a, b){
  return a + b;
}

箭头函数简洁的语法非常适合嵌入函数的场景
let ints = [1, 2, 3]
ints.map((i) => {return i + 1})

如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数情况下，才需要使用括号

//等价
let double = x => { return 3 * x }
let double = (x) => { return 3 * x }

//没有参数要括号
let getRandom = () => { return Math.random() }

//多个参数需要括号
let sum = (a, b) => { return a + b }

箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中
包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，
或者一个表达式。而且，省略大括号会隐式返回这行代码的值。

let double = (x) => {return x * 3}
let triple  = (x) => 3 * x

箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能
用作构造函数。此外，箭头函数也没有prototype属性。

10.2 函数名

因为函数名就是指向函数的指针，所以他们跟其他包含对象指针的变量来具有相同的行为。这意味着一个函数
可以有多个名称

function sum(num1, num2){
  return num1 + num2;
}

console.log(sum(10, 10))          //20

let anotherSum = sum;
console.log(anotherSum(10, 10))   //20

sum = null;
console.log(anotherSum(10, 10))   //20

注意，使用不带括号的函数名会访问函数指针，而不会执行函数。

ECMAScript6的所有函数对象都会暴露一个只读的name属性，其中包含关于函数的信息。多数情况下，这个属性
中保存的就是一个函数标识符。或者说是一个字符串化的变量名。即使函数没用名称，也会如实显示成空字符串。
如果它是使用Function构造函数创建的，则会标识成"anonymous"

function foo() {}
let bar = function(){ }
let baz = () => {}

console.log(foo.name)               //foo
console.log(bar.name)               //bar
console.log(baz.name)               //baz
console.log((() => {}).name)        //
console.log((new Function()).name)  //anonymous

如果函数是一个获取函数、设置函数，或者使用bind()实例化，那么标识符前面会加上一个前缀：

function foo(){ }
console.log(foo.bind(null).name)    //bound foo

let dog = {
  years: 1,
  get age(){
    return this.years;
  },
  set age(newAge){
    this.years = newAge;
  }
}

let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age')
console.log(propertyDescriptor.get.name)  //get age
console.log(propertyDescriptor.set.name)  //set age

10.3 理解参数

ECMAScript函数的参数跟大多数其他语言不同。ECMAScript函数既不关心传入的参数个数，也不关心参数的
数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至要给也
不穿，解释器都不会报错。

之所以这样，主要是因为ECMAScript函数的参数再内部表现为一个数组。函数被调用时总会接收一个数组，但
函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没
问题。事实上，再使用function关键字定义(非箭头)函数是，可以在函数内部访问arguments对象，从中取得
传进来的每个参数值。

arguments对象是一个类数组对象（但不是Array的实例），隐藏可以使用中括号语法访问其中的元素（第一个参数
是arguments[0]，第二个参数是arguments[1]）。而要确定传进来多少个参数可以访问arguments.length属性

function sayHi(name, message){
  console.log('Hello ' + name + ', ' + message)
}

function sayHi(){
  console.log('Hello ' + arguments[0] + ', ' + arguments[1])
}

表明，ECMAScript函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在ECMAScript中
的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。

arguments对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步。

function doAdd(num1, num2){
  arguments[1] = 10;
  console.log(arguments[0] + num2)
}

这个doAdd()函数把第二个参数的值重写为10.因为arguments对象的值会自动同步到对应的命名参数，所以
修改arguments[1]也会修改num2的值，因此两者的值都是10.但这并不意味着他们都访问同一个内存地址，他们
在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传一个参数，然后把arguments[1]
这只为某个值，那么这个值并不会反映到第二个命名参数。这是因为arguments对象的长度是根据传入的参数
个数，而非定义函数时给出的命名参数的个数决定的。

对于命名参数而言，如果调用函数时没有传给这个参数，那么它的值就是Undefined。这就类似于定义了变量
而没有初始化。比如，如果址给doAdd()传了一个参数，那么Num2的值就是undefined。

严格模式下，arguments会有一些变化。首先，像签名那也给arguments[1]赋值不会再影响num2的值。就算把
arguments[1]设置为10，num2的值仍然还是传入的值。其次，再函数中尝试重写arguments对象会导致语法错误。

箭头函数中的参数

如果函数是使用箭头语法定义的，那么穿给函数的参数将不能使用arguments关键字访问，而只能通过定义的
命名参数访问。

注意：ECMAScript中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递
的值就是这个对象的引用。

10.4 没有重载

ECMAScript函数不能像传统编程那样重载。再其他语言比如java中，一个函数可以有两个定义，只要签名（
接收参数的类型和数学）不同就行。如前所示ECMAScript函数没有签名，因为参数是由包含零个或多个值的
数组标识的。没有函数签名，字然也就没有重载了。

如果再ECMAScript中定义了两个同名函数，则后定义的会覆盖先定义的。

10.5 默认参数

在ECMAScript5.1及以前，实现默认参数的一种常用方式就是检测某个参数是否等于undefined,如果是则意味
这没有传这个参数，那就给它赋一个值：

function makeKing(name = 'Henry'){
  return `king ${name} VIII`
}

在使用默认参数时，arguments对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟ES5严格模式
一样，修改命名参数也不会影响arguments对象，它始终以调用函数时传入的值为准：

function makeKing(name = 'Henry'){
  name = 'Louis'
  return `King ${arguments[0]}`
}
console.log(makeKing())         //King undefined
console.log(makeKing('Louis'))  //King Louis

默认参数值并不限于原始值或对象类型，也可以使用调用返回的值
let romanNumberals = ['1', '2', '3', '4']
let ordinality = 0;

function getNumberals(){
  return romanNumberals[ordinality++]
}

function makeKing(name = 'Henry', numerals = getNumberals()){
  return `King ${name} ${numerals}`
}

console.log(makeKing())   //King Henry 1

函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数只有在调用
函数但未传相应参数时才会被调用。

箭头函数统一也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了；

let makeKing = (name = 'Henry') => `King ${name}`


默认参数作用域于暂时性死区

因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。
function makeKing(name = 'Henry', numberals = 'VIII'){
  return `King ${name} ${numerals}`
}
console.log(makeKing())

这里的默认参数会按照定义他们的顺序依次被初始化。

因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。

function makeKing(name = 'Henry', numerals = name){
  return `King ${name} ${numerals}`
}

console.log(makeKing())
//King Henry Henry

参数初始化顺序遵循“暂时性死区”规则，即签名定义的参数不能引用后面定义的。像这样会抛出错误：
function makeKing(name = numerals, numerals = 'VIII'){
  return `King ${name} ${numerals}`
}
console.log(makeKing())
//VM106:1 Uncaught ReferenceError: Cannot access 'numerals' before initialization

参数也存在于自己的作用域中，他们不能引用函数体的作用域
function makeKing(name = 'Henry', numerals = defaultNumeral){
  let defaultNumeral = 'VIII'
  return `King ${name} ${numerals}`
}
console.log(makeKing())
//Uncaught ReferenceError: defaultNumeral is not defined

10.6 参数扩展于收集
ECMAScript6新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是
使用函数定义中的参数列表，在这里可以充分利用这门语言的弱类型及参数长度可变的特点。扩展操作符既可以
用于调用函数时传参，也可以用于定义函数参数。

10.6.1 扩展参数

10.6.1 收集参数
在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合未一个数组。这有点类似arguments对象的
构造机制，只不过收集参数的结果会得到一个Array实例。

function getSum(...values){
  return values.reduce((x, y) => x + y, 0)
}

console.log(getSum(1,2 ,3))

使用收集参数并不影响arguments对象，它仍然反映调用时传给函数的参数。

10.7 函数声明于函数表达式

javascript引擎在加载数据时对他们是区别对待的。javascript引擎在任何代码执行之前，会先读取函数声明
并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数
定义。

console.log(sum(10, 10))
function sum(num1, num2){
  return num1 + num2;
}

以上代码可以正常允许，因为函数声明会在任何代码执行之前被读取并添加到执行上下文。这个过程叫作
函数声明提升（function declaration hoisting）。在执行代码时，javascript引擎会先执行一遍扫描，
把发现的函数声明提升到原代码数的顶部。因此即使函数定义出现在调用他们的代码之后，引起也会把函数
声明提升到顶部。如果改为函数表达式，那么执行的适合就会出错：

注意： 在使用函数表达式初始化变量时，也可以给函数一个名称，比如let sum = function sum(){}

10.8 函数作为值

因为函数名在ECMASCript中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把
函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。

function callSomeFunction(someFunction, someArgument){
  return someFunction(someArgument)
}