变量、作用域和内存

4.1 原始值与引用值
ECMAScript可以包含两种不同类型的数据：原始值和引用值
原始值（primitive value）：就是最简单的数据
引用值（reference value）:则是由多个值构成的对象

在把一个值赋给变量时：javascript引擎必须确定这个值是原始值还是引用值。
6中原始值 Null undefined boolean number string symbol
保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值
引用值是保存在内存中的对象。与其他语言不同，js不允许直接访问内存位置，因此也就不能直接操作对象
所在的内存空间。在操作对象时，实际上操作的是对该对象的引用而非实际对象本身。为此，保存引用值得变量
是按引用访问得。
注: 在很多语言中，字符串是使用对象表示的，因此被认为是引用类型，ECMAScript打破了这个惯例
4.1.1 动态属性

原始值和引用值的定义方式很类似，都是创建一个变量，然后给他赋一个值。不过，在变量保存了这个值之后
可以对这个值作什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。
如：let person = new Object()
person.name = 'nichalas'
console.log(person.name)  //nichalas
这里首先创建了一个对象，并把它保存在变量person中。然后，给这个对象添加一个名为name的属性，并
给这个属性赋值了一个字符串“Nicholas”。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式
地删除
原始值不能有属性，尽管尝试给原始值添加属性不会报错
let name = 'Nicholas'
name.age = 18
console.log(name.age)
注意：原始类型的初始化只使用原始字面量形式。如果使用的是new关键字，则js会创建一个object类型的实例
但行为类似原始值。
let name1 = 'Nicholas'
let name2 = new String('Matt')
name1.age = 27
name2.age = 22
console.log(name1.age)    //undefined
console.log(name2.age)    //22
console.log(typeof name1)   //string
console.log(typeof name2)   //object
4.1.2 复制值
除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值给另一个变量
时，原始值会被复制到新变量的位置。
let num = 1
let num2 = num;
这里，num包含数值1，把num2初始化为num时，num2也会得到数值1.这个值跟存储在num中的1是完全独立的，
因为他是那个值的副本
两个变量可以独立使用
在把引用值从一个变量赋值给另一个变量时，存储在变量中的值也被复制到新变量所在的位置。区别在于，这里
复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，
因此一个对象上面的变化会在另一个对象上反映出来
let obj1 = new Object();
let obj2 = obj1;
obj1.name = 'Nicholas'
console.log(obj2.name) //nicholas


4.1.3 传递参数

ECMAScript中所有的参数都是按值传递的。这意味着函数之外的值会被复制到函数内部的参数中，就像
从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的赋值一样，如果是引用值，那么
就跟引用值变量的赋值一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，
而传参则只有按值传递。

在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话来说，就是arguments
对象中的一个槽位）。
在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到
外部函数。（这在ECMAScript中是不可能的）

例：
function addTen(num){
  num += 10;
  return num;
}

let count = 20;

let result = addTen(count)
console.log(count)      //20
console.log(result)     //30

这里，函数addTen() 有一个参数num，他其实是一个局部变量。在调用时候，变量count作为参数传入。count
的值是20，这个值被复制到参数num以便在addTen()内部使用。在函数内部，参数num被加上10，但这不会影响
函数外部的原始变量count。参数num和变量count互不干扰，他们只不过碰巧保存了一样的值。如果num是
按照引用传递的，那么count的值也会被修改为30.这个事实在使用数值这样的原始值是非常明显的。但是，
如果变量中传递的是对象，就没有那么清楚了。

function setName(obj){
  obj.name = 'nicholas'
}
let persion = new Object();
setName(persion);
console.log(persion.name) //nicholas

这一次，我们创建了一个对象并把它保存在变量person中。然后，这个对象被传为setName()方法，并被复制
到参数obj中。在函数内部，obj和person都指向同一个对象。结果就是，即使对象是按值传进函数的，obj也
会通过引用访问对象。党函数内部给obj设置了name属性时，函数外部的对象也会反映这个变化，因为obj指向
的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时
就意味着参数时按引用传递的。为证明对象是按值传递的，我们看个例子

function setName(obj){
  obj.name = 'nicholas'
  obj = new Object();
  obj.name = 'Greg'
}

let person = new Object();
setName(person);
console.log(person.name)  //nicholas

这个例子前后唯一的变化就是setName()中多了两行代码，将obj重新定义为一个有着不通name的新对象。当
person传入setName()是，其name属性被设置为nicholas。然后变量obj被设置为一个新对象且name属性被
设置为Greg。如果person是按引用传递的，那么person应自动将指针改为指向name为greg的对象。可是，当
我们再次访问person.name时，它的值是nicholas，这表明函数中参数的值改变之后，原始的引用任然没有变
当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了

共享传递----引用副本

注意：ECMAScript中函数的参数就是局部变量

4.1.4 确定类型
typeof

基础类型
let s = 'nicholas'
console.log(typeof s) //string

instanceof
引用类型
let p = new Object()
let a = new Array()
let r = new RegExp(/a/);
console.log(p instanceof Object)  //true
console.log(p instanceof Array)   //false
console.log(r instanceof RegExp)  //true


按照定义，所有引用值都是Object的实例，因此通过instanceof操作符检测任何引用值和Object构造函数
都会返回true。类似地，如果用instanceof检测原始值，则始终返回false，因为原始值不是对象。

4.2 执行上下文与作用域

执行上下文（简称 “上下文”）的概念在js中颇为重要。变量或函数的上下文决定了他们可以访问哪些数据，以及
他们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和
函数都存在与这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器
中，全局上下文就是我们常说的window对象，因此所有通过var定义的全局变量和函数都会称为window对象的属性
和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在
其所有代码都指向完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被
销毁，比如关闭网页或退出浏览器）。

每个函数调用都有自己的上下文。当代码指向流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完
之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个
上下文栈进行控制的。

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文
中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是
函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量:arguments。（
全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。
以此类推直至全局上下文；全局上下文的变量对象始终值作用域链的最后一个变量对象。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，
然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）

var color = 'blue'

function changeColor(){
  if(color === 'blue'){
    color = "red"
  }else{
    color = 'blue'    
  }
}
changeColor();

对这个例子而言，函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments
对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域
链中找到它。

此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。例：

var color = "blue"

function changeColor(){
  let anotherColor = 'red';

  function swapColors(){
    let tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
    //这里可以访问color, anotherColor, tempColor
  }
  //这里可以访问color, anotherColor, 但访问不到tempColor
  swapColors();
}
//这里只能访问color
changeColor()

以上代码涉及3个上下文：全局上下文、changeColor()的局部上下文和swapColors()的局部上下文。全局
上下文中有个一个变量color和一个函数changeColor()。changeColor()的局部上下文中有一个变量anotherColor
和一个函数swapColors()，但在这里可以访问全局上下文中的变量color。swapColors()的局部上下文中有一个
变量tempColor，只能在上个上下文中访问到。全局上下文和changeColor()的局部上下文都无法访问到tempColor。
而在swapColors()中则可以访问另外两个上下文中的变量，因为他们都是父上下文。

图-展示了这个例子的作用域链

window
  |
  ----color
  |
  ----changeColor()
            |
            ----anotherColor
            |
            ----swapColors()
                    |
                    ----tempColor

图中的矩形表示不同的上下文。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问
内部上下文中的任何东西。上下文之间的连线是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变
量和函数，但任何上下文都不能到下一级上下文中去搜索。swapColors()局部上下文的作用域链中有三个对象：
swapColors()的变量对象、changeColor()的变量对象和全局对象。swapColors()的局部上下文首先从自己的
变量对象开始搜索变量和函数，搜不到就去搜索上一级变量对象。changeColor()上下文的作用域只有两个对象
它自己的变量对象和全局变量对象。因此，它不能访问swapColors()的上下文。

注：函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同访问规则。


4.2.1 作用域链增强

虽然执行上下文主要有全局上下文和函数上下文两种(eval()调用内部存在第三种上下文)，但又其他方式来增强
作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后被删除。通常在两种
情况下会出现这个现象，即代码执行到下面任意一种情况时：
·try/catch语句的catch块
·with语句
这两种情况下，都会在作用域链前端添加一个变量对象。对于with语句来说，会向作用域前端添加指定的对象；
对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

例：

function buildUrl(){
  let qs = '?debug=true'

  with(location){
    let url = href + qs;
  }

  return rul;
}

这里，with语句将location对象作为上下文，因此location会被添加到作用域前端。builderUrl()函数中
定义了一个变量qs。当with语句中的代码引用变量href时，实际上引用的时location.href，也就是自己变量
对象的属性。在引用qs时，引用的则是定义在buildUrl()中的那个变量，它定义在函数上下文的变量来对象上
。而with语句中使用var声明的变量url会成为函数上下文的一部分，可以作为函数的值被返回；但像这里使用
let声明的变量url，因为被限制在块级作用域，所以在with块之外没有定义


4.2.2 变量声明