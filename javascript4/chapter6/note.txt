集合引用类型

本章内容：对象、数组与定型数组、Map、weakMap、Set以及WeakSet类型

6.1 Object

到目前位置，大多数引用值得示例使用的是Object类型。Object是ECMAScript中最常用的类型之一。虽然object
的实例没有多少功能，但很适合存储和在应用程序间交换数据。

显式地创建Object的实例有两种方式。第一种是使用new操作符和Object构造函数，如下所示：
let person = new Object();
person.name = 'Nicholas'
person.age = 29;

另外一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了
简化包含大量属性的对象的创建。

let person = {
  name: 'Nicholas',
  age: 29
}

在这个例子中，左大括号表示对象字面量的开始，因为它出现在一个表达式上下文呢（expression context）中
在ECMAScript中，表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号
表示一个表达式的开始。同样是左大括号，如果出现在语句上下文(statement context)中，比如if语句的条件
后面，则表示一个语句块的开始。

对象字面量表示法中，属性名可用是字符串或数值。
let person = {
  "name": 'nicholas',
  5: true
}

注意： 数值属性会自动转换为字符串。
当然也可用用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行
let person = {}

//对象字面量通常只在为了让属性一目了然时才使用。
注意：在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。

let person = {
  name: 'nicholas',
  'first name': 'xxx'
}

person['name']
person['first name']

6.2 Array

ECMAScript数组跟其他编程语言的数组有很大区别。
跟其他语言中的数组一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以
存储任意的数据。这意味着可以创建一个数组，['aaa', 123, {a:123}]。ECMAScript数组也是动态大小的，
会随着数据添加而自动增长。

创建数组
let colors = new Array();

//创建初始length为20的数组
let colors = new Array(20)
//包含特定值的数组
let colors = new Array('greg')  //['greg']

在使用Array构造函数时，也可以省略new操作符。结果一样的，
let colors = Array(3)
let names = Array('greg')

另一种创建数组的方式是使用数组字面量（Array literal）表示法。
let colors = ['red', 'blue', 'green']

注意： 与对象一样，使用数组字面量表示法创建数组不会调用Array构造函数

Array构造函数换有两个ES6新增的用于创建数组的静态方法：from()和of()
from()用于将类数组解构转换为数组实例，
of()用于将一组参数转换为数组实例

Array.from()的第一个参数是一个类数组对象，即任何可迭代的构造，或者有一个length属性和可所有元素的
结构。

console.log(Array.from('Matt')) //(4) ["M", "a", "t", "t"]

可以使用from()将集合和映射换为一个新数组
const m = new Map().set(1, 2)
                   .set(3, 4)
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4)
console.log(Array.from(m))  //[[1, 2], [3, 4]]
console.log(Array.from(s))  //[1, 2, 3, 4]

//Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1)

console.log(a1)             //[1, 2, 3, 4]
console.log(a1 === a2)      //false

//可以使用任何可迭代对象
const iter = {
  *[Symbol.iterator](){
    yield 1;
    yield 2;
    yield 3;
    yield 4;
  }
}
console.log(Array.from(iter))

//arguments对象可以被轻松转换为数组
function getArgsArray(){
  return Array.from(arguments);
}
console.log(getArgsArray(1, 2, 3, 4))   //[1, 2, 3, 4]

//form()也能转换带有必要属性的自定义对象
const ArrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
}
console.log(Array.from(ArrayLikeObject))  //[1, 2, 3, 4]

Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无需向调用Array.from().map()
那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值
在箭头函数中不适用

const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, x => x**2);   //[1, 4, 9, 16]
const a3 = Array.from(a1, function(x){return x**this.exponent}, {exponent: 2}) //[1, 4, 9, 16]

Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments)
console.log(Array.of(1, 2, 3, 4));  //[1, 2, 3, 4]
console.log(Array.of(undefined))    //[undefined]

6.2.2 数组空位

使用数组字面量初始化数组时，可以使用遗传逗号来创建空位(hole)。ECMAScript会将逗号之间相应索引位置的
值当成空位，ES6规范重写定义了该如何处理这些空位。

const options = [,,,,,]   //(5) [empty × 5]

ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的
元素，这不过值为Undefined
const options = [1,,,,,5]
for(const option of options){
  console.log(option == undefined, option)
}

const a = Array.from([,,,])
for(const val of a){
  console.log(val == undefined)
}
//true
//true
//true

console.log(Array.of(...[,,,]))   //(3) [undefined, undefined, undefined]

const options = [1,,,,,5]
for(const [index, value] of options.entries()){
  console.log(value)
}

console.log(options.join('-'))    //1-----5

6.2.3 数组索引

取值或设置值用中括号并提供相应的数字索引
let colors = ['red', 'blue', 'green']
console.log(colors[1])
colors[1] = 'orange'
console.log(colors[1])

数组length属性的独特之处在于，他不是只读的。通过修改length属性，可以从数组末尾删除或添加元素
let colors = ['red', 'blue', 'green']
colors.length = 2;
console.log(colors, colors[2])    //(2) ["red", "blue"] undefined
这里，数组colors一开始有3个值。将length设置为2，就删除了最后一个(位置2的)值，因此colors[2]就没有
值了。如果将Length设置为大于数组元素数的值，则新添加的元素都将以undefined填充
let colors = ['red', 'blue', 'green']
colors.length = 5;
console.log(colors)     //(5) ["red", "blue", "green", empty × 2]

使用Length属性可以方便地向数组末尾添加元素，如下：
let colors = ['red', 'blue', 'green']
colors[colors.length] = 'black';
colors[colors.length] = 'brown';  
//(5) ["red", "blue", "green", "black", "brown"]

注意：数组最多可以包含4 294 967 295个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，
会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本允许时间过长的错误。

6.2.4 检测数组

一个经典的ECMAScript问题是判断一个对象是不是数组。只有在一个网页（因而只有一个全局作用域）的情况下
使用Instanceof操作符就足矣：

if(value instanceof Array){
  //操作数组
}

使用instanceof的问题是假定只有一个全局执行上下文。如果网页里面有多个框架，则可能涉及两个不同的全局
执行上下文，因此就会有两个不同版本的Array构造函数。如果要把数组从一个框架传给另一个框架，则这个数组
的构造函数将有别于第二个框架内本地创建的数组

为了解决这个问题，ECMAScript提供了Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而
不用管它是在哪个全局执行上下文中创建的。
Array.isArray(value)

6.2.5 迭代器方法

在ES6中，Array的原型上暴露了3个用于检索数组内容的方法：keys()、 values()和entries()。keys()返回数组索引的迭代器，values()
返回数组元素的迭代器，而entries()返回索引/值的迭代器：
//因为这些二方法都返回迭代器，所以可以将他们的内容通过Array.from()直接转换为数组实例
const a = ['foo', 'bar', 'baz', 'qux']
const aKeys = Array.from(a.keys())
const aValues = Array.from(a.values())
const aEntries = Array.from(a.entries())

console.log(aKeys)      //(4) [0, 1, 2, 3]
console.log(aValues)    //(4) ["foo", "bar", "baz", "qux"]
console.log(aEntries)
// 0: (2) [0, "foo"]
// 1: (2) [1, "bar"]
// 2: (2) [2, "baz"]
// 3: (2) [3, "qux"]

使用ES6的结构可以非常容易地在拳皇中拆分键/值对：
const a = ['foo', 'bar', 'baz', 'qux']
for( const [idx, element] of a.entries()){
  console.log(idx, element)
}
// 0 "foo"
// 1 "bar"
// 2 "baz"
// 3 "qux"

6.2.6 赋值和填充方法

ES6新增了两个方法：批量复制方法copyWithin()，以及填充数组方法fill()。这两个方法的函数签名类似，
都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。

使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是
可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象
成数组长度加上它得到得一个正索引；

const zeroes = [0, 0, 0, 0, 0]

zeroes.fill(5)
console.log(zeroes) //(5) [5, 5, 5, 5, 5]
zeroes.fill(0)
console.log(zeroes) //(5) [0, 0, 0, 0, 0]

//用6填充索引大于等于3得元素
zeroes.fill(6, 3)
console.log(zeroes) //(5) [0, 0, 0, 6, 6]
zeroes.fill(0)
console.log(zeroes) //(5) [0, 0, 0, 0, 0]
//用7填充索引大于等于1且小于3的元素
zeroes.fill(7, 1, 3)
console.log(zeroes) //(5) [0, 7, 7, 0, 0]
zeroes.fill(0)
console.log(zeroes) //(5) [0, 0, 0, 0, 0]
//用8填充索引大于等于1且小于4的元素
//(-4 + zeroes.length = 1)
//(-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1);
console.log(zeroes) //(5) [0, 8, 8, 8, 0]

fill()静默忽略超出数组边界、零长度即方向相反的索引范围

const zeroes = [0, 0, 0, 0, 0]
//索引过低，忽略
zeroes.fill(1, -10, -6);
console.log(zeroes) //[0, 0, 0, 0, 0]

//索引过高，忽略
zeroes.fill(1, 10, 15);
console.log(zeroes) //[0, 0, 0, 0, 0]

//索引反向，忽略
zeroes.fill(2, 4, 2)
console.log(zeroes) //[0, 0, 0, 0, 0]

//所有部分可用，填充可用部分
zeroes.fill(4, 3, 10)
console.log(zeroes) //[0, 0, 0, 4, 4]

与fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将他们插入到指定所有开始的位置
开始索引和结束索引则于fill()使用同样的计算方法。

copyWithin(x, y, z)
x(必填)：表示要替换的位置，从该位置开始替换，负数的话就到数
y(可选)：表示该位置开始读取元素，那这个位置的元素去换，负数的话就到数
z(可选)：表示该位置结束读取元素，拿到这个位置的元素去换，负数的话就到数。

let ints, 
    reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
//从ints中复制索引0开始的内容，插入到索引5开始的位置
//在源索引或目标索引到达数组边界时停止
ints.copyWithin(5)
console.log(ints)   //(10) [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

//从ints中复制索引5开始的内容，插入到索引0开始的位置
ints.copyWithin(0, 5)
console.log(ints)   //(10) [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

//从ints中复制索引0开始到索引3结束的内容
//插入到索引4开始的位置
ints.copyWithin(4, 0, 3)
console.log(ints)
reset();

javascript引擎在插值前会完整复制范围内的值
//因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6)
console.log(ints)     //(10) [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]
reset()
//支持负索引值，于fill()相对于数组末尾计算正向索引的过程是一样的
//(-4 + ints.length = 6)
//(-7 + ints.length = 3)
//(-3 + ints.length = 7)
ints.copyWithin(-4, -7, -3);
console.log(ints)     //(10) [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]

copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：
let ints, 
    reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();

//索引过低，忽略
ints.copyWithin(1, -15, -12)
console.log(ints);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

//索引过高，忽略
ints.copyWithin(1, 12, 15)
console.log(ints);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

//索引相反，忽略
ints.copyWithin(2, 4, 2)
console.log(ints);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()
//索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10)
console.log(ints)   //(10) [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]

6.2.7 转换方法

前面提到过，所有对象都有toLocaleString()、toString()和valueOf()方法，valueOf()返回的还是数组
本身。而toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组
的每个值都会调用其toString()方法，以得到最终字符串。
例：
let colors = ['red', 'blue', 'green']
console.log(colors.toString())    //red,blue,green
console.log(colors.valueOf())     //['red', 'blue', 'green']
console.log(colors)               //['red', 'blue', 'green']
首先是被显式调用的toString()和valueOf()方法。他们分别返回了数组的字符串表示，即将所有的字符串组合
起来，以逗号分隔。
toLocaleString()也可能返回跟toString()和valueOf()相同的结果，但也不一定。在调用数组的toLocaleString()
方法时，会得到一个逗号分割的数组值的字符串。它的另外两个方法唯一的区别是，为了得到最终得字符串，会
调用数组每个值得toLocaleString()方法，而不是toString()方法。
let person1 = {
  toLocaleString(){
    return 'Nicholas';
  },
  toString(){
    return 'Nicholas'
  }
}

let person2 = {
  toLocaleString(){
    return 'Grigorios';
  },
  toString(){
    return "Greg"
  }
}

let people = [person1, person2];
console.log(people)                   //[{toLocaleString: ƒ, toString: ƒ}, ...]
console.log(peopele.toString())       //Nicholas,Greg
console.log(people.toLocaleString())  //Nicholas,Grigorios

6.2.8 栈方法

ECMAScript给数组提供了几个方法，让它看起来像一个数据结构，数组可以像栈一样。
push()、pop()

6.2.9 队列方法
push()、shift()
push()推入一项
shift()取第一项

也可以通过unshift()和pop()实现队列
unshift()在数组头添加值
pop队尾取值

6.2.10 排序方法

reverse()和sort()
reverse反向排序

sort
默认情况下，sort()会按照升序重写排序数组，即最小的值在最前面，最大的值在最后面。为此，sort()会在
每一项上调用String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会数组转换为字符串
再比较、排序。
let values = [0, 1, 5, 10, 15]
values.sort()
console.log(values)
一开始数组中的数值顺序是正确的，但调用sort()会按照这些数值的字符串形式重新排序。因此，即使5小于10
但字符串“10”在“5”的前头，所以10还是会排序到5的前面，这在多数情况下都不是最合适的。
sort()方法可以接收一个比较函数
比较函数接收两个参数，
如果第一个参数应该排在第二个参数前面，就返回负值；
如果两个参数相等，就返回0
如果第一个参数应该排在第二个参数后面，就返回正值。
//升序
function compare(value1, value2){
  if(value1 < value2){
    return -1;
  }else if(value1 > value2){
    return 1;
  }else{
    return 0;
  }
}

例：
let values = [0, 1, 5, 10, 15]
values.sort(compare)
console.log(values)   //(5) [0, 1, 5, 10, 15]

reverse()和sort()都返回调用他们数组的引用

6.2.11 操作方法
concat()
方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后在把他的参数添加到
副本末尾，最后返回这个新构建的数组
let colors = ['red', 'green', 'blue']
let colors2 = colors.concat('yellow', ['black', 'brown'])
console.log(colors2)
//(6) ["red", "green", "blue", "yellow", "black", "brown"]

打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。
这个符号可以阻止concat()打平参数数组。相反这个值设置为true可以强制打平类数组对象：
let colors = ['red', 'green', 'blue']
let newColors = ['black', 'brown']
let moreNewColors = {
  [Symbol.isConcatSpreadable]: true,
  length: 2,
  0: 'pink',
  1: 'cyan'
}
newColors[Symbol.isConcatSpreadable] = false;

//强制不打平数组
let colors2 = colors.concat('yellow', newColors);
//强制打平类数组对象
let colors3 = colors.concat(moreNewColors)

slice()
//用于创建一个包含原由数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素
的开始索引和结束索引。操作不影响原数组
let colors = ['red', 'green', 'blue', 'yellow', 'purple']
let colors2 = colors.slice(1)
let colors3 = colors.slice(1, 4)

console.log(colors2)    //["green", "blue", "yellow", "purple"]
console.log(colors3)    //["green", "blue", "yellow"]

注意：如果slice()的参数有负值，那么就以数值长度加上这个负值的结果确定位置
比如：5个元素 slice(-2, -1)，就相当于调用slice(3, 4)

splice()
·删除 需要给splice()传入两个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意
      多个元素.比如splice(0, 2)会删除前两个元素
·插入 需要给splice()传入3个参数：开始位置、0（要山粗的元素数量）和要插入的元素，可以在以数组中指定
      的位置插入元素。第三个参数之后换可以传入第四个、第五个参数，乃至任意多个要插入的元素。
      比如.splice(2, 0, 'red', 'green')会从数组位置2开始插入字符串'red'和'green'
·替换 splice()在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量
      和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。
      比如splice(2, 1, 'red', 'green')会在位置2删除一个元素，然后从该位置开始向数组中插入'red'和
      'green'
      splice返回数组中被删除的元素（如果没有删除的元素，则返回空数组）
let colors = ['red', 'blue', 'green'];
let res = colors.splice(1, 1, 'grep', 'cray')
console.log(colors) //(4) ["red", "grep", "cray", "green"]
console.log(res)    //['blue']

6.2.12 搜索和位置方法

ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索

1.严格相等

ECMAScript提供了3个严格相等的搜索方法：indexOf()、lastIndexOf()和includes()。其中，前两个方法
在所有版本中都可以用，而第三个方法是ECMAScript7新增的。这些方法都接收两个参数：要查找的元素和一个
可选的起始搜索位置。indexOf()和includes()方法从数组前面开始向后搜索，而lastIndexOf()从数组末尾
开始向前搜索。

indexOf()和lastIndexOf()都返回要查找的元素在数组中的位置，如果没有找到则返回-1.
includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用
全等（===）比较，也就是说两项必须严格相等。
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]
console.log(numbers.indexOf(4))     //3
console.log(numbers.lastIndexOf(4)) //5
console.log(numbers.includes(4))    //true

console.log(numbers.indexOf(4, 4))     //5
console.log(numbers.lastIndexOf(4, 4)) //3
console.log(numbers.includes(4, 7))    //false

let person = {name: 'Nicholas'};
let people = [{name: 'Nicholas'}];
let morePeople = [person];

console.log(people.indexOf(person))       //-1
console.log(morePeople.indexOf(person))   //0
console.log(people.includes(person))      //false
console.log(morePeople.includes(person))  //true

2.断言函数

ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引
元素是否被认为匹配。

断言函数接收3个参数：元素、索引和数组本身。其中元素是数组中当前所示的元素，索引是当前元素的索引，而
数组就是正在搜索的数组。断言函数返回真值，表示是否匹配

find()和findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的
元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数
内部this的值。

const people = [
  {name: 'Matt', age: 27},
  {name: 'Nicholas', age: 29},
]

console.log(people.find((element, index, array) => element.age < 28))
//{name: "Matt", age: 27}

console.log(people.findIndex((element, index, array) => element.age < 28))
//0

找到匹配项后，这两个方法都不在继续搜索。
const evens = [2, 4, 6]

evens.find((element, index, array) => {
  console.log(element, index, array)
  return element === 4;
})
//2 0 [2, 4, 6]
//4 1 [2, 4, 6]

6.2.13迭代器方法
ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为
函数运行上下文的作用域对象（影响函数中this的值）。传给每个方法的函数接收3个参数：数组元素、元素索引
数组本身。数组的5个迭代方法如下：
·every():对数组每一项运行传入的函数，如果对每一项函数都返回true，则这个方法返回true。
·filter()：对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回。
·forEach()：对数组每一项都运行传入的函数，没有返回值。
·map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
·some()：对数组每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true。
这些方法都不改变调用他们的数组

6.2.14 归并方法

ECMAScript为数组提供了两个归并方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，并
在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。
这两个方法都接受两个参数：对每一项都会运行的归并函数，以及可选的以之位归并起点的初始值。传给reduce()
和reduceRight()的函数接收4个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值
都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），
则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。
例：
let values = [1, 2, 3, 4, 5];
let sum = values.reduce((prev, cur, index, array) => prev + cur);
console.log(sum)  //15
第一次执行归并函数时，prev是1，cur是2.第二次执行时，prev是3（1+2）,cur是3（数组第三项）。如此递进
知道把所有项都遍历一次，最后返回归并结果。

reduceRight()方法与之类似，只是方向相反。
let values = [1, 2, 3, 4, 5]
let sum = values.reduceRight(function(prev, cur, index, array){
  return prev + cur;
})
console.log(sum)    //15

6.3 定型数组

定型数组（typed array）是ECMAScript新增的结构，目的是提升向原生库传输数据的效率。实际上，javascript
并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。位理解如何使用定型数组，有必要先
了解一项它的用途

Mozilla为解决这个问题实现了CanvasFloatArray。这是一个提供javascript接口的、c语言风格的浮点值数组。
javascript运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序API，也可以
直接从底层获取到。最终，CanvasFloatArray变成了Float32Array，也就是今天定型数组中可用的第一个“类型”

6.3.2 ArrayBuffer

Float32Array实际上是一种“视图”，可以允许javascript运行时访问一块名为ArrayBuffer的预分配内存。
ArrayBuffer是所有定型数组及视图引用的基本单位。

注意 SharedArrayBuffer是ArrayBuffer的一个变体，可以无须复制就在执行上下文间传递。

ArrayBuffer()是一个普通的javascript构造函数，可用于在内存中分配特定数量的字节空间。
const buf = new ArrayBuffer(16)   //在内存中分配16字节
console.log(buf.byteLength)       //16

ArrayBuffer一经创建就不能在调整大小。不过，可用使用slice()复制其全部或部分到一个新实例中。
const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4, 12)
console.log(buf2.byteLength)

ArrayBuffer某种程度上类似于c++的malloc()，但也有几个明显的区别
·malloc()在分配失败时会返回一个null指针。ArrayBuffer在分配失败时会抛出错误。
·malloc()可用利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer分配的内存不能超过
Number.MAX_SAFE_INTEGER(2^53 - 1)字节
·通过malloc()分配的堆内存除非调用free()或程序退出，否则系统不能再使用。而通过声明ArrayBuffer分配的
堆内存可用被当初垃圾回收，不用手动释放。

不能仅通过对ArrayBuffer的引用就的读取和写入其内容。要读取和写入ArrayBuffer，就必须通过视图。视图有
不同的类型，得但引用的都是ArrayBuffer中存储的二进制数据。

6.3.3 DataView

第一种允许你读写ArrayBuffer的视图是DataView。这个视图转为文件I/O和网络I/O设计，其API支持对缓存数据
的高度控制，但相比于其他类型的视图性能也差一些。DataView对缓冲内容没用任何预设，也不能迭代。
必须再对已有的ArrayBuffer读写或写入时才能创建DataView实例。这个实例可以使用全部或部分ArrayBuffer，
且维护者对该缓冲实例的引用，以及视图在缓冲种开始的位置。

const buf = new ArrayBuffer(16);

//DataView默认使用整个ArrayBuffer
const fullDataView = new DataView(buf);
console.log(fullDataView.byteOffset);     //0
console.log(fullDataView.byteLength);     //16
console.log(fullDataView.buffer === buf)  //true

构造函数接收一个可选的字节偏移量和字节长度
byteOffset=0 表示视图从缓冲起点开始
byteLength=8 限制视图为前8个字节
const firstHalfDataView = new DataView(buf, 0, 8);
console.log(firstHalfDataView.byteOffset)     //0
console.log(firstHalfDataView.byteLength)     //8
console.log(firstHalfDataView.buffer === buf) //true

//如果不指定，则DataView会是使用剩余的缓冲
byteOffset=8表示视图从缓冲的第9个字节开始
byteLength未指定，默认为剩余缓冲
const secondHalfDataView = new DataView(buf, 8);
console.log(secondHalfDataView.byteOffset)    //8
console.log(secondHalfDataView.byteLength)    //8
console.log(secondHalfDataView.buffer === buf)//true

要通过DataView读取缓冲，还需要几个组件。
·首先是要读或写的字节偏移量。可以看成DataView中的某种“地址”
·DataView应该使用ElementType来实现javascript的number类型到缓冲内二进制格式的转换
·最后是内存中只得字节序。默认为大端字节序

1.ElementType
DataView对存储在缓冲内得数据类型没用预设。它暴露得API强制开发者在读、写时指定一个ElementType，然后
DataView就会忠实第为读、写而完成相应得转换。

ECMAScript6支持8中不同得ElementType
         字节         说明              等价的c类型            值的范围
int8      1       8为有符号整数         signed char           -128~127
Uint8     1       8位无符号整数         unsigned char         0~255
Int16     2       16位有符号整数        short                 -32768~32767
Uint16    2       16位无符号整数        unsigned short        0~65535
Int32     4       32位有符号整数        int                   -2147483648~2147483647
Uint32    4       32位无符号整数        unsigined int         0~4294967295
Float32   4       32位IEEE-754浮点数    float                 -3.4e+38~+3.4e+38
Float64   8       64位IEEE-754浮点数    double                -1.7e+308~+-1.7e+308

DataView为上表中的每种类型都暴露了get和set方法，这些方法使用byteOffset(字节偏移量)定位要读取或
写入值得位置。类型是可以互换使用的。

//在内存中分配两个字节并声明一个DataView
const buf = new ArrayBuffer(2)
const view = new DataView(buf);

//说明整个缓冲确实所有二进制位都是0
//检查第一个和第二个字符
console.log(view.getInt8(0))    //0
console.log(view.getInt8(1))    //0
//检查整个缓冲
console.log(view.getInt16(0))   //0

//将整个缓冲都设置位1
//255个二进制表示是11111111（2^8 - 1）
view.setUint8(0, 255);

//DataView自动将数据转换为特定的ElementType
//255的十六进制表示是0xFF
view.setUint8(1, 0xFF)

//现在，缓冲里都是1了
//如果把它当成二补数的有符号整数，则应该是-1
console.log(view.getInt16(0))   //-1


2.字节序

前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算机系统维护的一种字节顺序的约定。
DataView只支持两种约定：大端字节序和小端字节序。
大端字节序也称为 “网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节序
小端字节序正好小贩，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。

javascript运行时所在系统的原生字节序决定了如何读取或写入字节，但DataView并不遵守这个约定。对一段
内存而言，DataView是一个中立接口，它会遵循你指定的字节序。DataView的所有API方法 都以大端字节序
为默认值，但接收一个可选的布尔值参数，设置为true即可启用小端字节序
//在内存中分配两个字节并声明一个DataView
const buf = new ArrayBuffer(2);
const view = new DataView(buf);

//填充缓冲，让第一位和最后一位都是1
view.setUint8(0, 0x80)  //设置最左边的位等于1
view.setUint8(1, 0x01)  //设置最右边的位等于1

//缓冲内容位（位方便阅读，人为加了空格）
//0x8  0x0  0x0  0x1
//1000 0000 0000 0001

//按大端字节序读取Uint16
//0x80是高字节，0x01是低字节
//0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769;
console.log(view.getUint16(0))

//按小端字节序读取Uint16
//0x01是高字节，0x80是低字节
//0x0180 = 2^8 + 2^7 = 256 + 128 = 384;
console.log(view.getUint16(0, true))

//按大端字节写入Uint16
view.setUint16(0, 0x0004);

//缓冲内容（位方便阅读，认为加入了空格）
//0x0  0x0  0x0  0x4
//0000 0000 0000 0100

console.log(view.getUint8(0));
console.log(view.getUint8(1));

//按小端字节序写入Uint16
view.setUint16(0, 0x0002, true);

//缓冲内容
//0x0  0x2  0x0  0x0
//0000 0100 0000 0000

console.log(view.getUint8(0))
console.log(view.getUint8(1))

3.边界情形

DataView完成读、写操作的前提是必须有充足的缓冲区，否则会抛出RangeError：

const buf = new ArrayBuffer(6)
const view = new DataView(buf);
//尝试读取部分超出缓冲范围的值
view.getInt32(4);

view.getInt32(8);

view.getInt32(-1);

view.setInt32(4, 123);

DataView在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为0.如果无法转换，则抛出错误：

const buf = new ArrayBuffer(1)
const view = new DataView(buf);

view.setInt8(0, 1.5);     
console.log(view.getInt8(0))    //1

view.setInt8(0, [4]);
console.log(view.getInt8(0))    //4

view.setInt8(0, 'f');
console.log(view.getInt8(0))    //0

view.setInt8(0, Symbol())

6.3.4 定型数组


定型数组是另一种形式的ArrayBuffer视图。虽然概念上于DataView接近，但定型数组的区别在于，特定于一种
ElementType且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API和更高的性能。设计定型数组
的目的就是提高与webGl等原生库交换二进制数据的效率。由于定型数组的二进制表示对操作系统而言是一种容易
使用的格式，javascript引擎可以重度优化算数运算、按位运算和其他对定型数组的常见操作，因此使用他们速度
极快。

创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。
另外，通过<ElementType>.from()和<ElementType>.of()也可以创建定型数组：

//创建一个12字节的缓冲
const buf = new ArrayBuffer(12);
//创建一个引用该缓冲的Int32Array
const ints = new Int32Array(buf)
//这个定型数组知道自己的每个元素需要4字节，因此长度为3
//ArrayBuffer(12)从内存分配了12字节的内存
//int为四字节，
//所以从ArrayBuffer转为Int32Array length变成了 12 / 4 = 3
console.log(ints.length)    //3       

//创建一个长度为6的Int32Array
//创建了6个 四字节int数据类型  总共6 * 4 = 24字节
const ints2 = new Int32Array(6)
//每个数值使用4字节，因此ArrayBuffer是24字节
console.log(ints2.length)   //6
//类似DataView，定型数组也有一个指向关联缓冲的引用
console.log(ints2.buffer.byteLength)  //24

//创建一个包含[2, 4, 6, 8]的Int32Array
const ints3 = new Int32Array([2, 4, 6, 8])
console.log(ints3.length)             //4
4个int类型的长度 = 4 * 4 = 16个字节/ArrayBuffer 的长度
console.log(ints3.buffer.byteLength)  //16
console.log(ints3[2])                 //6

//通过复制ints3的值创建一个Int16Array
const ints4 = new Int16Array(ints3) 
//这个新类型数组会分配自己的缓冲
//对于索引的每个值会相应地转换为新格式
console.log(ints4.length)             //4
console.log(ints4.buffer.byteLength)  //8
console.log(ints4[2])                 //6

const ints5 = Int16Array.from([3, 5, 7, 9])
console.log(ints5.length)             //4
console.log(ints5.buffer.byteLength)  //8
console.log(ints5[2])                 //7

const floats = Float32Array.of(3.14, 2.718, 1.618);
console.log(floats.length)            //3
console.log(floats.buffer.byteLength) //12
console.log(floats[2])                //1.618xxxxxx

定型数组的构造函数和实例都有一个BYTES_PER_ELEMENT属性，返回该类型数组中每个元素的大小：
console.log(Int16Array.BYTES_PER_ELEMENT) //2
console.log(Int32Array.BYTES_PER_ELEMENT) //4

const ints = new Int32Array(1)
const floats = new Float64Array(1)
console.log(ints.BYTES_PER_ELEMENT)       //4
console.log(floats.BYTES_PER_ELEMENT)     //8

如果定型数组没有用任何值初始化，则其关联的缓冲会以0填充

const ints = new Int32Array(4);
console.log(ints[0])    //0
console.log(ints[1])    //0
console.log(ints[2])    //0
console.log(ints[3])    //0

1.定型数组行为
从很多方面看，定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：
·[]
·copyWithin()
·entries()
·every()
·fill()
·filter()
·find()
·findInde()
·forEach()
·indexOf()
·join()
·keys()
·lastIndexOf()
·length
·map()
·reduce()
·reduceRight()
·reverse()
·slice()
·some()
·sort()
·toLocaleString()
·toString()
·values()

其中，返回新数组的方法也会返回包含同样元素类型的新定型数组：
const ints = new Int16Array([1, 2, 3])
const doubleints = ints.map(x => 2 * x);
console.log(doubleints instanceof Int16Array, doubleints)
//true  Int16Array(3) [2, 4, 6]

定型数组有一个Symbol.iterator符号属性，因此可以通过for..of循环和扩展操作符来操作：
const ints = new Int16Array([1, 2, 3])
for(const int of ints){
  console.log(int)
}
//1
//2
//3

console.log(Math.max(...ints))    //3

2.合并、复制和修改定型数组
定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小。因此，下列方法不适用于定型数组：
concat()
pop()
push()
shift()
splice()
unshift()

不过，定型数组也提供了两个新方法，可以快速向外活向内复制数据：set()和subarray()。
set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置：

//创建长度为8的int16数组
const container = new Int16Array(8)
//把定型数组赋值为前4个值
container.set(Int8Array.of(1, 2, 3, 4))
console.log(container)
//Int16Array(8) [1, 2, 3, 4, 0, 0, 0, 0]


container.set([5, 6, 7, 8], 4)
console.log(container)
//Int16Array(8) [1, 2, 3, 4, 5, 6, 7, 8]

//溢出会抛出错误
container.set([5, 6, 7, 8], 7)
//RangeError

subarray()指向于set()相反的操作，它会基于从原始定型数组中赋值的值返回一个新定型数组
const source = Int16Array.of(2, 4, 6, 8)
const fullCopy = source.subarray();
console.log(fullCopy)     //Int16Array(4) [2, 4, 6, 8]

const partialCopy = source.subarray(1, 3)
console.log(partialCopy)  //Int16Array(2) [4, 6]

定型数组没有原生的拼接能力，但使用定型数组API提供的很多工具可以手动构建
//参数1：返回的数组类型，
//参数2：应该拼接在一起的定型数组
function typedArrayConcat(typedArrayConstructor, ...typedArrays){
  //计算所有数组中包含的元素总数
  const numElements = typedArrays.reduce((x, y) => (x.length || x) + y.length)
  //按照提供的类型创建一个数组，为所有元素留出空间
  const resultArray = new typedArrayConstructor(numElements)

  let currentOffset = 0;
  typedArrays.map(x => {
    resultArray.set(x, currentOffset)
    currentOffset += x.length;
  })

  return resultArray;
}

const concatArray = typedArrayConcat(
  Int32Array,
  Int8Array.of(1, 2, 3),
  Int16Array.of(4, 5, 6),
  Float32Array.of(7, 8, 9)
)
console.log(concatArray)    //Int32Array(9) [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(concatArray instanceof Int32Array)  //true

3. 上溢和下溢

定型数组中值的下溢和上溢不会影响到其他索引，但仍然需要考虑数组的元素应该是什么类型。定型数组对于
可以存储的每个索引只接收一个相关位  ，而不考虑他们对实际数值的影响
//长度位2的有符号整数数组
//每个索引保存一个二补数形式的有符号整数
//范围是-128（-1 * 2^7）~ 127（2^7 - 1）
const ints = new Int8Array(2)
//长度为2的无符号整数
//每个索引保存一个无符号整数
//范围是(0 ~ 255) 2^8 - 1
const unsignedInts = new Uint8Array(2)
//上溢位不会影响相邻索引
//索引只取最低有效位上的8位
unsignedInts[1] = 256;      //0x100
console.log(unsignedInts)   //[0, 0]
unsignedInts[1] = 511;      //0x1FF
console.log(unsignedInts)   //[0, 255]
//下溢的位会被转换为其无符号的等价值
//0xFF是以二进制的二补数表示的-1（截取到8位）
//但255是一个无符号整数
unsignedInts[1] = -1;       //0xFF
console.log(unsignedInts)   //[0, 255]
//上溢自动变为二补数的形式
0x80是无符号整数的128，是二补数形式的-128
ints[1] = 128;    //0x80
console.log(ints) //[0, -128]
//下溢自动变成二补数形式
//0xFF是无符号整数的255，是二补数形式的-1
ints[1] = 255;      //0xFF
console.log(ints)   //[0, -1]

除了8中元素类型，还有一种“夹板”数组类型：Uint8ClampedArray，不允许任何方向溢出。超出最大值255
的值会被向下舍入为255，而小于最小值0的值会被向上舍入为0
const clampedInts = new Uint8ClampedArray([-1, 0, 255, 256]);
console.log(clampedInts)    //Uint8ClampedArray(4) [0, 0, 255, 255]

6.4 Map
基本API
const m = new Map();
//如果像创建的同时初始化实例，可以给Map构造函数创建一个可迭代对象，需要包含键值对数组。
可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中。

const m1 = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])
console.log(m1)
//Map(3) {"key1" => "val1", "key2" => "val2", "key3" => "val3"}

//映射期待的键值对
const m3 = new Map([[]])
console.log(m3.has(undefined))  //true
console.log(m3.get(undefined))  //undefined

初始化之后，可以使用set()方法添加键值对。另外，可以使用get()和has()进行查询，可以通过size属性
获取映射中的键值对的数量，还可以使用delete()和clear()删除值
const m = new Map()
console.log(m.has('firstName'));  //false
console.log(m.get('firstName'))   //undefined
console.log(m.size)               //0

m.set('firstName', 'Matt')
 .set('lastName', 'Frisble') 
console.log(m.size)     //2

m.delete('firstName')

console.log(m.has('firstName'))   //false
console.log(m.has('lastName'))    //true
console.log(m.size)               //1

//清除这个映射实例中的所有键值对
m.clear()

console.log(m.has('firstName'))   //false
console.log(m.has('lastName'))    //false
console.log(m.size)               //0

set方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明
const m = new Map().set('key1', 'val1')

m.set('key2', 'val2')
 .set('key3', 'val3')
console.log(m.size)   //3

与Object只能使用数值、字符串或符号作为键不同，map可以使用任何javascript数据类型作为键。
Map内部使用SameValueZero比较操作（ECMAScript规范内部定义，语言中不能使用），基本上相当于
使用严格对象相等的标准来检查键的匹配性。与Object类似，映射的值是没有限制的。

const m = new Map()

const functionKey = function(){}
const symbolKey = Symbol();
const objectKey = new Object();

m.set(functionKey, "functionValue")
m.set(symbolKey, "symbolValue")
m.set(objectKey, "objectValue")

console.log(m.get(functionKey))   //functionValue
console.log(m.get(symbolKey))     //symbolValue
console.log(m.get(objectKey))     //objectValue

//SameValueZero比较意味着独立实例不冲突
console.log(m.get(function(){}));   //undefined

与严格模式一样，在映射中用作键和值的对象及其他'集合'类型，在自己的内容或属性被修改时仍然保持不变

const m = new Map()

const objKey = {}
const objVal = {}
const arrKey = []
const arrVal = []

m.set(objKey, objVal)
m.set(arrKey, arrVal)

objKey.foo = 'foo'
objVal.bar = 'bar'

arrKey.push('foo')
arrVal.push('bar')

console.log(m.get(objKey))    //{bar: "bar"}
console.log(m.get(arrKey))    //["bar"]

6.4.2 顺序与迭代

与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，因此可以根据插入顺序指向迭代操作。

映射实例可以提供一个迭代器(Iterator),能以插入顺序生成[key, value]形式的数组。可以通过entries()
方法（或者Symbol.iterator属性，它引用entries()）取得这个迭代器：
const m = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])
console.log(m.entries === m[Symbol.iterator]) //true

for(let pair of m.entries()){
  console.log(pair)
}
//[key1, val1]
//[key2, val2]
//[key3, val3]

for(let pair of m[Symbol.iterator]()){
  console.log(pair)
}
//[key1, val1]
//[key2, val2]
//[key3, val3]

因为entries()是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组：
const m = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])
console.log([...m])   //(3) [Array(2), Array(2), Array(2)]

如果不使用迭代器，而是使用回调函数方式，则可以调用映射的forEach(callback, opt_thisArg)方法并
传入回调，一次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值

const m = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])

m.forEach((val, key) => console.log(`${key} => ${val}`))

keys()和values()分别返回以插入顺序生成键和值的迭代器：

const m = new Map([
  ['key1', 'val1'],
  ['key2', 'val2'],
  ['key3', 'val3'],
])

for(let key of m.keys()){
  console.log(key)
}

for(let key of m.values()){
  console.log(key)
}

键和值在迭代器遍历时时可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值
的对象内部的属性，因为这样并不影响他们在映射实例中的身份：
const m1 = new Map([
  ['key1', 'val1']
]);

for(let key of m1.keys()){
  key = 'newKey'
  console.log(key)
  console.log(m1.get('key1'))
}
//newKey
//val1

const keyObj = {id:1}
const m = new Map([
  [keyObj, 'val1']
])

for(let key of m.keys()){
  key.id = 'newKey'
  console.log(key)
  console.log(m.get(keyObj))
}
//{id: "newKey"}
//val1

6.4.3 选择Object还是Map

对于多数web开发任务来说，选择Object还是Map只是个人偏好问题，影响不大。不过，对于在乎内存和性能
的开发者来说，对象和映射之间确实存在显著的差别。

1.内存占用
Object和Map的工程级实现在不同浏览器间存在明显差异，但存储单个键/值对所占用的内存数量都会随键的
数量线性增加。批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现。不同浏览器的情况
不同，但给定固定大小的内存，Map大约可以比Objectuo存储50%的键值对。
2.插入性能
像object和Map中插入新键值对的消耗大致相当，不过插入Map在所有浏览器中一般会稍微快一点。对这两个
类型来说，插入速度并不会随着键值对数量而线性增加。如果代码设计大量插入操作，那么显然map的性能更佳。
3.查找速度
与插入不同，从大小Object和Map总查找键值对的性能差异极小，但如果只包含少量键值对，则object是时候
速度更快。在把Object当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在
内存中使用更高效的布局。这对Map来说是不可能的。对这两个类型而言，查找速度不会随着键值对数量增加
而线性增加。如果代码涉及大量查找操作，那么某些情况下可能选择Object更好一些。
4.删除性能
使用delete删除Object属性的性能一直以来饱受诟病，目前在很多浏览器中仍然如此。为此，出现了一些伪
删除对象属性的操作，包括把属性值设置额伪undefined或null。但很多时候，这都是一种讨厌的或不适宜的
这种。而对大多数浏览器引擎来说，Map的delete()操作都比插入和查找更快。如果涉及当量删除操作，那么毫无
疑问应该选择Map。

6.5 WeakMap

ECMAScript6新增的 “若映射”(WeakMap)是一种新的集合类型，伪这么语言带来了增强的键值对存储机制。
WeakMap是Map的“兄弟”类型，其API也是MAP的子集。WeakMap中的“weak”（弱），表述的是javascript垃圾回收
程序对待“弱映射”中键的方式

6.5.1 基本API

可以使用new关键字实例化一个空的weakMap
const wm = new WakMap();
若映射中的键只能是Object或者继承字Object的类型，尝试使用非对象设置键会抛出TypeError。值得类型没有
限制。

如果想在初始化时填充若映射，则构造函数可以接收一个可迭代对象，其中需要包含键值对数组。可迭代对象中
得每个键值都会按照迭代顺序插入新实例中：
const key1 = {id: 1}, 
      key2 = {id: 2},
      key3 = {id: 3}

//使用嵌套数组初始化弱映射
const wm1 = new WeakMap([
  [key1, 'val1'],
  [key2, 'val2'],
  [key3, 'val3'],
])
console.log(wm1.get(key1))
console.log(wm1.get(key2))
console.log(wm1.get(key3))

//初始化是全有或全无得操作
//只要有一个键无效就会抛出错误，导致整个初始化失败
const wm2 = new WeakMap([
  [key1, 'val1'],
  ["badkey", 'val2'],
  [key3, 'val3'],
])
//TypteError: Invalid value used as WeakMap key

//原始值可以先包装成对象在用作键
const stringKey = new String('key1');
const wm3 = new WeakMap([
  [stringKey, 'val1']
])
console.log(wm3.get(stringKey))   //val1

初始化之后可以使用set()再添加键值对，可以使用get()和has()查询，还可以使用delete()删除。

const wm = new WeakMap();

const key1 = {id:1},
      key2 = {id:2};

console.log(wm.has(key1))   //false
console.log(wm.get(key1))   //undefined

wm.set(key1, 'matt')
  .set(key2, 'frisbie')

wm.delete(key1)

console.log(wm.has(key1))   //false
console.log(wm.has(key2))   //true

set()方法返回弱映射实例，因此可以把多个操作连缀起来，包括初始化声明：

const key1 = {id:1},
      key2 = {id:2},
      key3 = {id:3};

const wm = new WeakMap().set(key1, 'val1')
wm.set(key2, 'val2')
  .set(key3, 'val3')

console.log(wm.get(key1))
console.log(wm.get(key2))
console.log(wm.get(key3))

6.5.2 弱键

weakMap中“weak”表示弱映射得键是“弱弱地拿着”的意思。意思就是，这些建不属于正式的引用，不会阻止垃圾
回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键值对就会存在与映射中，并被
当作对值得引用，因此就不会被当作垃圾回收。

const wm = new WeakMap()
wm.set({}, 'val')
set()方法初始化了一个新对象并将它用作一个字符串得键。因为没有指向这个对象得其他引用，所以当这行
代码指向完成后，这个对象键就会被当作垃圾回收。然后，这个键值对就从弱映射中消失了，使其成为一个空
映射。再这个例子中，因为值也没有被引用，所以这对键值被破坏后，值本身也会成为垃圾回收得目标。

const wm = new WeakMap()
const container = {
  key: {}
}
wm.set(container.key, 'val')

function removeReference(){
  container.key = null;
}
这一次，container对象维护着一个对弱映射得引用，因此这个对象键不会成为垃圾回收得目标。不过，如果
调用了removeReference()，就会摧毁键对象得最后一个引用，垃圾回收程序就可以把这个键值对清理掉。

6.5.3 不可迭代键
因为weakMap中得键值对任何时候都可能被销毁，所以没必要提供迭代其键值对得能力。当然，也用不着clear()
这样一次性销毁所有键值得方法。weakMap确实没有这个方法。因为不可能迭代，所以也不可能再不知道对象引用
得情况下从弱映射中取得值。即便代码可以访问weakMap实例，也没办法看到其中得内容。

weakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象得引用才能取得值。如果允许原始值，那
就没办法区分初始化时使用得字符串字面量和初始化之后使用得一个相等得字符串了

6.5.4 使用弱映射

weakMap实例与现有javascript对象有着很大不同，可能一时不容易说清楚应该怎么使用它。这个问题没有唯一
答案，但以及出现了很多相关策略

1.私有变量
若映射造就了在js中实现真正私有变量得一种新方法。前提很明确：私有变量会存储再弱映射中，以对象实例
为键，以私有成员的字典为值。

const wm = new WeakMap();

class User{
  constructor(id){
    this.idProperty = Symbol('id')
    this.setId(id)
  }

  setPrivate(property, value){
    const privateMembers = wm.get(this) || {}
    privateMembers[property] = value;
    wm.set(this, privateMembers)
  }

  getPrivate(property){
    return wm.get(this)[property];
  }

  setId(id){
    this.setPrivate(this.idProperty, id);
  }

  getId(){
    return this.getPrivate(this.idProperty)
  }
}


const user = new User(123);
console.log(user.getId())   //123
user.setId(456);
console.log(user.getId())   //456

//并不是真正私有的
console.log(wm.get(user)[user.idProperty])    //456

对于上面的实现，外部代码只需要拿到对象实例的引用和弱映射，就可以取得“私有”变量了。为了避免这种访问，
可以用一个闭包把weakMap包装起来，这样就可以把弱映射与外界隔离开了。

const User = (() => {
  const wm = new WeakMap();

  class User{
    constructor(id){
      this.idProperty = Symbol('id')
      this.setId(id)
    }

    setPrivate(property, value){
      const privateMembers = wm.get(this) || {}
      privateMembers[property] = value;
      wm.set(this, privateMembers)
    }

    getPrivate(property){
      return wm.get(this)[property];
    }

    setId(id){
      this.setPrivate(this.idProperty, id);
    }

    getId(){
      return this.getPrivate(this.idProperty)
    }
  }
  return User;
})();

const user = new User(123);
console.log(user.getId())   //123
user.setId(456);
console.log(user.getId())   //456

这样，拿不到弱映射中的键，也就无法取得弱映射中对于的值。虽然这防止了前面提到的访问，但整个代码也
完全陷入了ES6之前的闭包私有变量模式。

2.DOM节点元数据

因为WeakMap实例不会妨碍垃圾回收，所以非常适合保存关联元数据。来看下面这个例子，其中使用了常规的map

const m = new Map();

const loginButton = document.querySelector('#login')

m.set(loginButton, {disabled: true})

假设在上面的代码指向后，页面被js改变了，原来的登录按钮从DOM树种被删掉了。但由于映射中还保存着按钮
的引用，所以对于的DOM节点仍然会逗留在内存中，除非明确将其从映射中删除或者等到映射本身被销毁。
如果这里使用的是弱映射，如以下代码所示，那么当节点从DOM树中被删除后，垃圾回收程序就可以立即释放
其内存（假设每月其他任何引用这个对象）

const wm = new WeaMap()
const loginButton = document.querySelector('#login')
wm.set(loginButton, {disabled: true})

6.6 Set

Set在很多方面都象时加强的MAP，这是因为他们的大多数API和行为都是公有的。

6.6.1 基本API

const m = new Set();

//创建同时初始化
const s1 = new Set(['val1', 'val2', 'val3'])
console.log(s1.size)  //3

//使用自定义迭代器初始化集合
const s2 = new Set({
  [Symbol.iterator]: function* (){
    yield 'val1';
    yield 'val2';
    yield 'val3';
  }
})
console.log(s2.size)  //3

初始化之后，可以使用add()增加值，使用has()查询，通过size取得元素数量，以及使用delete()和clear()
删除元素
const s = new Set();

console.log(s.has('matt'))  //false
console.log(s.size)         //0

s.add('matt')
 .add('frisbie')

console.log(s.has('matt'))  //true
console.log(s.size)         //2

s.delete('matt')

console.log(s.has('matt'))    //false
console.log(s.has('frisbie')) //true
console.log(s.size)           //1

//销毁结合实例中的所有值
s.clear();

console.log(s.has('matt'))    //false
console.log(s.has('frisbie')) //false
console.log(s.size)           //0

add()返回集合的实例，所以可以将多个添加操作连缀起来，包括初始化：

const s = new Set().add('val1')

s.add('val2')
 .add('val3')
console.log(s.size)   //3

与Map类似，Set可以包含任何js数据类型作为值。集合也使用SameValueZero操作，基本上相当于使用严格对象
相等的标准来检查值得匹配性

const s = new Set()

const functionVal = function(){}
const symbolVal = Symbol()
const objectVal = new Object();

s.add(functionVal)
s.add(symbolVal)
s.add(objectVal)

console.log(s.has(functionVal)) //true
console.log(s.has(symbolVal))   //true
console.log(s.has(objectVal))   //true

console.log(s.has(function(){}))  //false

与严格相等一样，用作值得对象和其他“集合”类型在自己的内容或属性被修改时也不会改变

const s = new Set();

const objVal = {},
      arrVal = [];

s.add(objVal)
s.add(arrVal)

objVal.bar = 'bar'
arrVal.push('bar')

console.log(s.has(objVal))  //true
console.log(s.has(arrVal))  //true

add()和delete()操作是幂等的。delete()返回一个布尔值，表示集合中是否存在要删除的值
const s = new Set();

s.add('foo')
console.log(s.size) //1
s.add('foo')
console.log(s.size) //1

console.log(s.delete('foo'))  //true

console.log(s.delete('foo'))  //false

6.6.2 顺序与迭代

set会维护值插入时的顺序，因此会支持按顺序迭代。
集合实例可以提供一个迭代器(Iterator)，能以插入顺序生成集合内容。可以通过values()方法及其别名方法
keys()取得这个迭代器

const s = new Set(['val1', 'val2', 'val3'])

console.log(s.values === s[Symbol.iterator])
console.log(s.keys === s[Symbol.iterator])

for(let value of s.values()){
  console.log(value)
}
//val1
//val2
//val3

for(let value of s[Symbol.iterator]()){
  console.log(value)
}
//val1
//val2
//val3

因为values()是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组：
const s = new Set(['val1', 'val2', 'val3'])
console.log([...s])   //(3) ["val1", "val2", "val3"]

集合的entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个
值重复出现
const s = new Set(['val1', 'val2', 'val3'])

for(let pair of s.entries()){
  console.log(pair)
}
//(2) ["val1", "val1"]
//(2) ["val2", "val2"]
//(2) ["val3", "val3"]

如果不适用迭代器，而是使用回调方式，则可以调用结合的forEach()方法并传入回调，依次迭代每个键值对。
传入的回调接收可选的第二参数，这个参数用于重写回调内部this的值：
const s = new Set(['val1', 'val2', 'val3'])

s.forEach((val, dupVal) => console.log(`${val} -> ${dupVal}`))

//val1 -> val1
//val2 -> val2
//val3 -> val3

修改集合中值的属性不会影响作为结合值得身份：
