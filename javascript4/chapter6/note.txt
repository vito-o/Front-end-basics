集合引用类型

本章内容：对象、数组与定型数组、Map、weakMap、Set以及WeakSet类型

6.1 Object

到目前位置，大多数引用值得示例使用的是Object类型。Object是ECMAScript中最常用的类型之一。虽然object
的实例没有多少功能，但很适合存储和在应用程序间交换数据。

显式地创建Object的实例有两种方式。第一种是使用new操作符和Object构造函数，如下所示：
let person = new Object();
person.name = 'Nicholas'
person.age = 29;

另外一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了
简化包含大量属性的对象的创建。

let person = {
  name: 'Nicholas',
  age: 29
}

在这个例子中，左大括号表示对象字面量的开始，因为它出现在一个表达式上下文呢（expression context）中
在ECMAScript中，表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号
表示一个表达式的开始。同样是左大括号，如果出现在语句上下文(statement context)中，比如if语句的条件
后面，则表示一个语句块的开始。

对象字面量表示法中，属性名可用是字符串或数值。
let person = {
  "name": 'nicholas',
  5: true
}

注意： 数值属性会自动转换为字符串。
当然也可用用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行
let person = {}

//对象字面量通常只在为了让属性一目了然时才使用。
注意：在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。

let person = {
  name: 'nicholas',
  'first name': 'xxx'
}

person['name']
person['first name']

6.2 Array

ECMAScript数组跟其他编程语言的数组有很大区别。
跟其他语言中的数组一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以
存储任意的数据。这意味着可以创建一个数组，['aaa', 123, {a:123}]。ECMAScript数组也是动态大小的，
会随着数据添加而自动增长。

创建数组
let colors = new Array();

//创建初始length为20的数组
let colors = new Array(20)
//包含特定值的数组
let colors = new Array('greg')  //['greg']

在使用Array构造函数时，也可以省略new操作符。结果一样的，
let colors = Array(3)
let names = Array('greg')

另一种创建数组的方式是使用数组字面量（Array literal）表示法。
let colors = ['red', 'blue', 'green']

注意： 与对象一样，使用数组字面量表示法创建数组不会调用Array构造函数

Array构造函数换有两个ES6新增的用于创建数组的静态方法：from()和of()
from()用于将类数组解构转换为数组实例，
of()用于将一组参数转换为数组实例

Array.from()的第一个参数是一个类数组对象，即任何可迭代的构造，或者有一个length属性和可所有元素的
结构。

console.log(Array.from('Matt')) //(4) ["M", "a", "t", "t"]

可以使用from()将集合和映射换为一个新数组
const m = new Map().set(1, 2)
                   .set(3, 4)
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4)
console.log(Array.from(m))  //[[1, 2], [3, 4]]
console.log(Array.from(s))  //[1, 2, 3, 4]

//Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1)

console.log(a1)             //[1, 2, 3, 4]
console.log(a1 === a2)      //false

//可以使用任何可迭代对象
const iter = {
  *[Symbol.iterator](){
    yield 1;
    yield 2;
    yield 3;
    yield 4;
  }
}
console.log(Array.from(iter))

//arguments对象可以被轻松转换为数组
function getArgsArray(){
  return Array.from(arguments);
}
console.log(getArgsArray(1, 2, 3, 4))   //[1, 2, 3, 4]

//form()也能转换带有必要属性的自定义对象
const ArrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
}
console.log(Array.from(ArrayLikeObject))  //[1, 2, 3, 4]

Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无需向调用Array.from().map()
那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值
在箭头函数中不适用

const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, x => x**2);   //[1, 4, 9, 16]
const a3 = Array.from(a1, function(x){return x**this.exponent}, {exponent: 2}) //[1, 4, 9, 16]

Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments)
console.log(Array.of(1, 2, 3, 4));  //[1, 2, 3, 4]
console.log(Array.of(undefined))    //[undefined]

6.2.2 数组空位

使用数组字面量初始化数组时，可以使用遗传逗号来创建空位(hole)。ECMAScript会将逗号之间相应索引位置的
值当成空位，ES6规范重写定义了该如何处理这些空位。

const options = [,,,,,]   //(5) [empty × 5]

ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的
元素，这不过值为Undefined
const options = [1,,,,,5]
for(const option of options){
  console.log(option == undefined, option)
}

const a = Array.from([,,,])
for(const val of a){
  console.log(val == undefined)
}
//true
//true
//true

console.log(Array.of(...[,,,]))   //(3) [undefined, undefined, undefined]

const options = [1,,,,,5]
for(const [index, value] of options.entries()){
  console.log(value)
}

console.log(options.join('-'))    //1-----5

6.2.3 数组索引

取值或设置值用中括号并提供相应的数字索引
let colors = ['red', 'blue', 'green']
console.log(colors[1])
colors[1] = 'orange'
console.log(colors[1])

数组length属性的独特之处在于，他不是只读的。通过修改length属性，可以从数组末尾删除或添加元素
let colors = ['red', 'blue', 'green']
colors.length = 2;
console.log(colors, colors[2])    //(2) ["red", "blue"] undefined
这里，数组colors一开始有3个值。将length设置为2，就删除了最后一个(位置2的)值，因此colors[2]就没有
值了。如果将Length设置为大于数组元素数的值，则新添加的元素都将以undefined填充
let colors = ['red', 'blue', 'green']
colors.length = 5;
console.log(colors)     //(5) ["red", "blue", "green", empty × 2]
