集合引用类型

本章内容：对象、数组与定型数组、Map、weakMap、Set以及WeakSet类型

6.1 Object

到目前位置，大多数引用值得示例使用的是Object类型。Object是ECMAScript中最常用的类型之一。虽然object
的实例没有多少功能，但很适合存储和在应用程序间交换数据。

显式地创建Object的实例有两种方式。第一种是使用new操作符和Object构造函数，如下所示：
let person = new Object();
person.name = 'Nicholas'
person.age = 29;

另外一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了
简化包含大量属性的对象的创建。

let person = {
  name: 'Nicholas',
  age: 29
}

在这个例子中，左大括号表示对象字面量的开始，因为它出现在一个表达式上下文呢（expression context）中
在ECMAScript中，表达式上下文指的是期待返回值的上下文。赋值操作符表示后面要期待一个值，因此左大括号
表示一个表达式的开始。同样是左大括号，如果出现在语句上下文(statement context)中，比如if语句的条件
后面，则表示一个语句块的开始。

对象字面量表示法中，属性名可用是字符串或数值。
let person = {
  "name": 'nicholas',
  5: true
}

注意： 数值属性会自动转换为字符串。
当然也可用用对象字面量表示法来定义一个只有默认属性和方法的对象，只要使用一对大括号，中间留空就行
let person = {}

//对象字面量通常只在为了让属性一目了然时才使用。
注意：在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。

let person = {
  name: 'nicholas',
  'first name': 'xxx'
}

person['name']
person['first name']

6.2 Array

ECMAScript数组跟其他编程语言的数组有很大区别。
跟其他语言中的数组一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以
存储任意的数据。这意味着可以创建一个数组，['aaa', 123, {a:123}]。ECMAScript数组也是动态大小的，
会随着数据添加而自动增长。

创建数组
let colors = new Array();

//创建初始length为20的数组
let colors = new Array(20)
//包含特定值的数组
let colors = new Array('greg')  //['greg']

在使用Array构造函数时，也可以省略new操作符。结果一样的，
let colors = Array(3)
let names = Array('greg')

另一种创建数组的方式是使用数组字面量（Array literal）表示法。
let colors = ['red', 'blue', 'green']

注意： 与对象一样，使用数组字面量表示法创建数组不会调用Array构造函数

Array构造函数换有两个ES6新增的用于创建数组的静态方法：from()和of()
from()用于将类数组解构转换为数组实例，
of()用于将一组参数转换为数组实例

Array.from()的第一个参数是一个类数组对象，即任何可迭代的构造，或者有一个length属性和可所有元素的
结构。

console.log(Array.from('Matt')) //(4) ["M", "a", "t", "t"]

可以使用from()将集合和映射换为一个新数组
const m = new Map().set(1, 2)
                   .set(3, 4)
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4)
console.log(Array.from(m))  //[[1, 2], [3, 4]]
console.log(Array.from(s))  //[1, 2, 3, 4]

//Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1)

console.log(a1)             //[1, 2, 3, 4]
console.log(a1 === a2)      //false

//可以使用任何可迭代对象
const iter = {
  *[Symbol.iterator](){
    yield 1;
    yield 2;
    yield 3;
    yield 4;
  }
}
console.log(Array.from(iter))

//arguments对象可以被轻松转换为数组
function getArgsArray(){
  return Array.from(arguments);
}
console.log(getArgsArray(1, 2, 3, 4))   //[1, 2, 3, 4]

//form()也能转换带有必要属性的自定义对象
const ArrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
}
console.log(Array.from(ArrayLikeObject))  //[1, 2, 3, 4]

Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无需向调用Array.from().map()
那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this的值。但这个重写的this值
在箭头函数中不适用

const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, x => x**2);   //[1, 4, 9, 16]
const a3 = Array.from(a1, function(x){return x**this.exponent}, {exponent: 2}) //[1, 4, 9, 16]

Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments)
console.log(Array.of(1, 2, 3, 4));  //[1, 2, 3, 4]
console.log(Array.of(undefined))    //[undefined]

6.2.2 数组空位

使用数组字面量初始化数组时，可以使用遗传逗号来创建空位(hole)。ECMAScript会将逗号之间相应索引位置的
值当成空位，ES6规范重写定义了该如何处理这些空位。

const options = [,,,,,]   //(5) [empty × 5]

ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的
元素，这不过值为Undefined
const options = [1,,,,,5]
for(const option of options){
  console.log(option == undefined, option)
}

const a = Array.from([,,,])
for(const val of a){
  console.log(val == undefined)
}
//true
//true
//true

console.log(Array.of(...[,,,]))   //(3) [undefined, undefined, undefined]

const options = [1,,,,,5]
for(const [index, value] of options.entries()){
  console.log(value)
}

console.log(options.join('-'))    //1-----5

6.2.3 数组索引

取值或设置值用中括号并提供相应的数字索引
let colors = ['red', 'blue', 'green']
console.log(colors[1])
colors[1] = 'orange'
console.log(colors[1])

数组length属性的独特之处在于，他不是只读的。通过修改length属性，可以从数组末尾删除或添加元素
let colors = ['red', 'blue', 'green']
colors.length = 2;
console.log(colors, colors[2])    //(2) ["red", "blue"] undefined
这里，数组colors一开始有3个值。将length设置为2，就删除了最后一个(位置2的)值，因此colors[2]就没有
值了。如果将Length设置为大于数组元素数的值，则新添加的元素都将以undefined填充
let colors = ['red', 'blue', 'green']
colors.length = 5;
console.log(colors)     //(5) ["red", "blue", "green", empty × 2]

使用Length属性可以方便地向数组末尾添加元素，如下：
let colors = ['red', 'blue', 'green']
colors[colors.length] = 'black';
colors[colors.length] = 'brown';  
//(5) ["red", "blue", "green", "black", "brown"]

注意：数组最多可以包含4 294 967 295个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，
会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本允许时间过长的错误。

6.2.4 检测数组

一个经典的ECMAScript问题是判断一个对象是不是数组。只有在一个网页（因而只有一个全局作用域）的情况下
使用Instanceof操作符就足矣：

if(value instanceof Array){
  //操作数组
}

使用instanceof的问题是假定只有一个全局执行上下文。如果网页里面有多个框架，则可能涉及两个不同的全局
执行上下文，因此就会有两个不同版本的Array构造函数。如果要把数组从一个框架传给另一个框架，则这个数组
的构造函数将有别于第二个框架内本地创建的数组

为了解决这个问题，ECMAScript提供了Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而
不用管它是在哪个全局执行上下文中创建的。
Array.isArray(value)

6.2.5 迭代器方法

在ES6中，Array的原型上暴露了3个用于检索数组内容的方法：keys()、 values()和entries()。keys()返回数组索引的迭代器，values()
返回数组元素的迭代器，而entries()返回索引/值的迭代器：
//因为这些二方法都返回迭代器，所以可以将他们的内容通过Array.from()直接转换为数组实例
const a = ['foo', 'bar', 'baz', 'qux']
const aKeys = Array.from(a.keys())
const aValues = Array.from(a.values())
const aEntries = Array.from(a.entries())

console.log(aKeys)      //(4) [0, 1, 2, 3]
console.log(aValues)    //(4) ["foo", "bar", "baz", "qux"]
console.log(aEntries)
// 0: (2) [0, "foo"]
// 1: (2) [1, "bar"]
// 2: (2) [2, "baz"]
// 3: (2) [3, "qux"]

使用ES6的结构可以非常容易地在拳皇中拆分键/值对：
const a = ['foo', 'bar', 'baz', 'qux']
for( const [idx, element] of a.entries()){
  console.log(idx, element)
}
// 0 "foo"
// 1 "bar"
// 2 "baz"
// 3 "qux"

6.2.6 赋值和填充方法

ES6新增了两个方法：批量复制方法copyWithin()，以及填充数组方法fill()。这两个方法的函数签名类似，
都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。

使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是
可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象
成数组长度加上它得到得一个正索引；

const zeroes = [0, 0, 0, 0, 0]

zeroes.fill(5)
console.log(zeroes) //(5) [5, 5, 5, 5, 5]
zeroes.fill(0)
console.log(zeroes) //(5) [0, 0, 0, 0, 0]

//用6填充索引大于等于3得元素
zeroes.fill(6, 3)
console.log(zeroes) //(5) [0, 0, 0, 6, 6]
zeroes.fill(0)
console.log(zeroes) //(5) [0, 0, 0, 0, 0]
//用7填充索引大于等于1且小于3的元素
zeroes.fill(7, 1, 3)
console.log(zeroes) //(5) [0, 7, 7, 0, 0]
zeroes.fill(0)
console.log(zeroes) //(5) [0, 0, 0, 0, 0]
//用8填充索引大于等于1且小于4的元素
//(-4 + zeroes.length = 1)
//(-1 + zeroes.length = 4)
zeroes.fill(8, -4, -1);
console.log(zeroes) //(5) [0, 8, 8, 8, 0]

fill()静默忽略超出数组边界、零长度即方向相反的索引范围

const zeroes = [0, 0, 0, 0, 0]
//索引过低，忽略
zeroes.fill(1, -10, -6);
console.log(zeroes) //[0, 0, 0, 0, 0]

//索引过高，忽略
zeroes.fill(1, 10, 15);
console.log(zeroes) //[0, 0, 0, 0, 0]

//索引反向，忽略
zeroes.fill(2, 4, 2)
console.log(zeroes) //[0, 0, 0, 0, 0]

//所有部分可用，填充可用部分
zeroes.fill(4, 3, 10)
console.log(zeroes) //[0, 0, 0, 4, 4]

与fill()不同，copyWithin()会按照指定范围浅复制数组中的部分内容，然后将他们插入到指定所有开始的位置
开始索引和结束索引则于fill()使用同样的计算方法。

copyWithin(x, y, z)
x(必填)：表示要替换的位置，从该位置开始替换，负数的话就到数
y(可选)：表示该位置开始读取元素，那这个位置的元素去换，负数的话就到数
z(可选)：表示该位置结束读取元素，拿到这个位置的元素去换，负数的话就到数。

let ints, 
    reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();
//从ints中复制索引0开始的内容，插入到索引5开始的位置
//在源索引或目标索引到达数组边界时停止
ints.copyWithin(5)
console.log(ints)   //(10) [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]
reset();

//从ints中复制索引5开始的内容，插入到索引0开始的位置
ints.copyWithin(0, 5)
console.log(ints)   //(10) [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]
reset();

//从ints中复制索引0开始到索引3结束的内容
//插入到索引4开始的位置
ints.copyWithin(4, 0, 3)
console.log(ints)
reset();

javascript引擎在插值前会完整复制范围内的值
//因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6)
console.log(ints)     //(10) [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]
reset()
//支持负索引值，于fill()相对于数组末尾计算正向索引的过程是一样的
//(-4 + ints.length = 6)
//(-7 + ints.length = 3)
//(-3 + ints.length = 7)
ints.copyWithin(-4, -7, -3);
console.log(ints)     //(10) [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]

copyWithin()静默忽略超出数组边界、零长度及方向相反的索引范围：
let ints, 
    reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset();

//索引过低，忽略
ints.copyWithin(1, -15, -12)
console.log(ints);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

//索引过高，忽略
ints.copyWithin(1, 12, 15)
console.log(ints);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()

//索引相反，忽略
ints.copyWithin(2, 4, 2)
console.log(ints);  //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
reset()
//索引部分可用，复制、填充可用部分
ints.copyWithin(4, 7, 10)
console.log(ints)   //(10) [0, 1, 2, 3, 7, 8, 9, 7, 8, 9]

6.2.7 转换方法

前面提到过，所有对象都有toLocaleString()、toString()和valueOf()方法，valueOf()返回的还是数组
本身。而toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组
的每个值都会调用其toString()方法，以得到最终字符串。
例：
let colors = ['red', 'blue', 'green']
console.log(colors.toString())    //red,blue,green
console.log(colors.valueOf())     //['red', 'blue', 'green']
console.log(colors)               //['red', 'blue', 'green']
首先是被显式调用的toString()和valueOf()方法。他们分别返回了数组的字符串表示，即将所有的字符串组合
起来，以逗号分隔。
toLocaleString()也可能返回跟toString()和valueOf()相同的结果，但也不一定。在调用数组的toLocaleString()
方法时，会得到一个逗号分割的数组值的字符串。它的另外两个方法唯一的区别是，为了得到最终得字符串，会
调用数组每个值得toLocaleString()方法，而不是toString()方法。
let person1 = {
  toLocaleString(){
    return 'Nicholas';
  },
  toString(){
    return 'Nicholas'
  }
}

let person2 = {
  toLocaleString(){
    return 'Grigorios';
  },
  toString(){
    return "Greg"
  }
}

let people = [person1, person2];
console.log(people)                   //[{toLocaleString: ƒ, toString: ƒ}, ...]
console.log(peopele.toString())       //Nicholas,Greg
console.log(people.toLocaleString())  //Nicholas,Grigorios

6.2.8 栈方法

ECMAScript给数组提供了几个方法，让它看起来像一个数据结构，数组可以像栈一样。
push()、pop()

6.2.9 队列方法
push()、shift()
push()推入一项
shift()取第一项

也可以通过unshift()和pop()实现队列
unshift()在数组头添加值
pop队尾取值

6.2.10 排序方法

reverse()和sort()
reverse反向排序

sort
默认情况下，sort()会按照升序重写排序数组，即最小的值在最前面，最大的值在最后面。为此，sort()会在
每一项上调用String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会数组转换为字符串
再比较、排序。
let values = [0, 1, 5, 10, 15]
values.sort()
console.log(values)
一开始数组中的数值顺序是正确的，但调用sort()会按照这些数值的字符串形式重新排序。因此，即使5小于10
但字符串“10”在“5”的前头，所以10还是会排序到5的前面，这在多数情况下都不是最合适的。
sort()方法可以接收一个比较函数
比较函数接收两个参数，
如果第一个参数应该排在第二个参数前面，就返回负值；
如果两个参数相等，就返回0
如果第一个参数应该排在第二个参数后面，就返回正值。
//升序
function compare(value1, value2){
  if(value1 < value2){
    return -1;
  }else if(value1 > value2){
    return 1;
  }else{
    return 0;
  }
}

例：
let values = [0, 1, 5, 10, 15]
values.sort(compare)
console.log(values)   //(5) [0, 1, 5, 10, 15]

reverse()和sort()都返回调用他们数组的引用

6.2.11 操作方法
concat()
方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后在把他的参数添加到
副本末尾，最后返回这个新构建的数组
let colors = ['red', 'green', 'blue']
let colors2 = colors.concat('yellow', ['black', 'brown'])
console.log(colors2)
//(6) ["red", "green", "blue", "yellow", "black", "brown"]

打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：Symbol.isConcatSpreadable。
这个符号可以阻止concat()打平参数数组。相反这个值设置为true可以强制打平类数组对象：
let colors = ['red', 'green', 'blue']
let newColors = ['black', 'brown']
let moreNewColors = {
  [Symbol.isConcatSpreadable]: true,
  length: 2,
  0: 'pink',
  1: 'cyan'
}
newColors[Symbol.isConcatSpreadable] = false;

//强制不打平数组
let colors2 = colors.concat('yellow', newColors);
//强制打平类数组对象
let colors3 = colors.concat(moreNewColors)



