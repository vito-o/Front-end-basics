/**
 * 1.HTTP和HTTPS
 * 
 * http和https的基本概念
 * 
 * http：是一个客户端和服务器端请求和应答的标准（TCP）,用于从www服务器传输超文本到本地
 * 浏览器的超文本传输协议。
 * 
 * https：是以安全为目标的HTTP通道，即http加入SSL层进行加密。启作用是：建立一个信息安全
 * 通道，来确保数据的传输，确保网站的真实性。
 * 
 * 2.http和https的区别及优缺点？
 * ·http是超文本传输协议，信息是明文传输，HTTPS协议要比http协议安全，https是具有安全性的
 * ssl加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性（当然这种安全性
 * 并非绝对的，对于更深入的web安全问题，此处暂且不表）
 * ·http协议的默认端口是80，https的默认端口为443。
 * ·http的连接很简单，是无状态的。https握手阶段比较费时，会使页面加再时间延长50%，增加
 * 10% ~ 20%的耗电。
 * ·https缓存不如http高效，会增加数据开销。
 * ·https协议需要ca证书，费用较高，功能越强大的证书费用越高
 * ·ssl证书需要绑定IP，并能在同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。
 * 
 * 3.https协议的工作原理，
 * 
 * 客户端在使用HTTPS方式于web服务器通信时有以下几个步骤：
 * 
 * 1.客户端使用https url访问服务器，则要求web服务器建立ssl链接
 * 2.web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。
 * 3.客户端和web服务器端开始协商ssl链接的安全等级，也就是加密等级。
 * 4.客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥
 * 并传送给网站。
 * 5.web服务器通过自己的私钥解密出会话密钥
 * 6.web服务器通过会话密钥加密与客户端之间的通信
 * 
 * TCP三次握手
 * 
 * 1.第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，
 * 等待服务器确认；
 * SYN:同步序列编号
 * 2.第二次握手：服务器收到syn包并确认客户端SYN（ack=j+1），同时也发送一个自己的SYN包
 * （syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
 * 3.第三次握手：客户端收到服务器的SYN+ACK包，像服务器发送确认包ACK（ack=k+1），此包
 * 发送完毕，客户端和服务器进入ESTABLISHED(TCP连接成功)状态，完成三次握手。
 * 
 * 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
 * 
 * TCP四次挥手
 * 
 * 1.客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号
 * 为seq=u(等于前面已经传送过来的数据的最后一个字节的序号加1)，此时，客户端进入FIN-WAIT-1
 * （终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号
 * 
 * 2.服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，
 * 此时服务端就进入了CLOSE-WAIT(关闭等待)状态。TCP服务器通知高层的应用进程，客户端向服务
 * 器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但时服务器若要
 * 发送数据，客户端依然要接收，这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续时间。
 * 
 * 3.客户端收到服务器的确认请求后，此时，客户端就进入了FIN-WAIT-2（终止等待2）状态，等待
 * 服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
 * 
 * 4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在
 * 半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入
 * 了LASST-ACK（最后确认）状态，等待客户端的确认。
 * 
 * 5.客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是
 * seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，
 * 必须经过2**MSL（最长报文端寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
 * 
 * 6.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次
 * 的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
 * 
 * 
 * 
 * TCP/IP 如何保证数据包传输的序列可靠
 * 
 * 对字节流分段并进行编号然后通过ACK回复和超时重发这两个机制来保证。
 * 
 * 1.为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区
 * 2.并为每个已发送的数据包启动一个超时定时器；
 * 3.如果定时器超时之前收到了对方发来的应答信息（可能是对本报的应答，也可以是对本报后续包的
 * 应答），则释放该数据包占用的缓冲区。
 * 4.否则，重传该数据包，知道收到应答或重传次数超过规定的最大次数为止。
 * 5.接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个
 * 累计应答包，表明该数据已接受到，如果接收方正好也有数据要发送给发送方，应答包也可在数据
 * 包中捎带过去。
 * 
 * TCP和UDP的区别
 * 
 * 1.TCP是面响链接的，而UDP是面向无连接的。
 * 2.TCP支持单播传输，UDP提供了单播、多播、广播的功能。
 * 3.TCP的三次握手保证了连接的可靠性；UDP是无连接的、不可靠的一种数据传播协议，首先不可靠
 * 性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道
 * 数据是否会正确接收。
 * 4.UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。
 * 
 * HTTP请求跨域问题
 * 
 * 1.跨域的原理
 * 
 * 跨域，是指浏览器不能执行其他网站的脚本。他是由浏览器的同源策略造成的。
 * 同源策略，是浏览器对js实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是
 * 不同的域。
 * 跨域原理，即是通过各种方式，避开浏览器的安全限制。
 * 
 * 2.解决方案
 * 
 * 最初做项目的时候，使用的是jsonp，但存在一些 问题，使用get请求不安全，携带数据较小，
 * 后来也用过iframe，但只有主域相同才行，也是存在一些问题，后来通过了解和学习发现使用代理
 * 和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用
 * proxy，在服务器上使用nginx，这样开封府过程中彼此都方便，效率也搞；限制h5新特性还有
 * windows.postMessage()
 * 
 * ·jsonp：
 *  ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域
 * 的js脚本，利用这个特性，服务端不再返回json格式的数据，而是返回一段调用某个函数的js代码，
 * 在src中进行了调用，这样实现了跨域。
 * 
 * 步骤
 * 1.去创建一个script标签
 * 2.script的src属性设置接口地址
 * 3.接口参数，必须要带一个自定义函数名，要不然后台也无法返回数据
 * 4.通过定义函数名去接收返回的数据
 * 
 * //动态创建script
    var script = document.createElement('script')

    //设置回调函数
    function getData(data) {
      console.log(data)
      eval(data)
    }

    //设置script的src属性，并设置请求地址
    script.src = 'http://localhost:8888/aa?callback=getData'

    //让script生效
    document.body.appendChild(script)
 * 
 * JSON只支持get，因为script标签只能使用get请求；jsonp需要后端配合返回指定格式的数据。
 * ·document.domain基础域名相同 子域名不同
 * ·window.name利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name
 * ·CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理；
 * 服务器设置Access-Control-Allow-Origin HTTP响应头之后哦，浏览器将会允许跨域请求
 * ·proxy代理 目前常用方式，通过服务器设置代理
 * ·window.postMessage()利用h5新特性window.postMessage()
 * 
 * Cookie、sessionStorage、localStorage的区别
 * 
 * 相同点：
 * ·存储在客户端
 * 
 * 不同点：
 * ·cookie数据大小不能超过4k；sessionStoragehelocalStorage的存储比cookie大得多，可以
 * 达到5M+
 * ·cookie设置的过期时间之前一直有效；local Storage永久有效，浏览器关闭后数据不丢失除非
 * 主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
 * ·cookie的数据会自动传递到服务器；sessionStorage和localStorage数据保存在本地
 * 
 * 粘包问题分析域对策
 * 
 * TCP粘包是指发送方发松的若干报数据到接收方接收时粘成一包，从数据缓冲区看，后医保数据的头
 * 紧接着前一包数据的尾。
 * 
 * 粘包出现原因
 * 
 * 简单地说，在流传输中出现，UDP不会出现粘包，因为它由消息边界
 * 粘包情况有两种，一种是站在一起的包都是完整的数据包，另一种情况是站在一起的包由不完整的包。
 * 
 * 为了避免粘包现响，可采取以下几种措施
 * 1.对于发送方引起的粘包现响，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令
 * push，TCP软件收到该操作指令后，立即将本段数据发送出去，而不必等待发送缓冲区满；
 * 2.对于接收放引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施
 * 使其及时接收数据，从而尽量避免出现粘包现象。
 * 3.由接收方控制，将一段数据按结构字段，认为控制分多次接收，然后合并，通过这种手段来避免粘包。
 * 分包多发。
 * 
 * 以上提高到的三种措施，都有其不足之处。
 * 1.第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，
 * 影响引用程序的性能，一般不建议使用。
 * 2.第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络
 * 突发可能使某一个时间端数据包到达接收放较快，接收放还使有可能来不及接收，从而导致粘包。
 * 3.第三种方法虽然避免了粘包，但应用程序的效率较底，对实时应用的场合不合适。
 * 
 * 一种比较周全的对策使：接收放创建一预处理线程，对接收到的数据包进行预处理，将粘连的
 * 包分开。实验证明这种方法使高效可行的
 * 
 * 
 * 浏览器
 * 
 * 从输入URL到页面加再的全过程
 * 
 * 1.首先在浏览器种输入url
 * 2.查找缓存：浏览器先查看浏览器缓存-系统缓存-路由器缓存种是否有该地址页面，如果有则显示页面
 * 内容，如果没有则进行下一步。
 * ·浏览器缓存：浏览器会记录DNS一段时间，因此，知识第一个地方解析DNS请求；
 * ·操作系统缓存：如果在浏览器缓存种不包含这个记录，则会使用系统调用操作系统，获取操作系统
 * 的几率（保存最近的DNS查询缓存）
 * ·路由缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
 * ·ISP缓存：若上述均失败，继续向ISP搜索。
 * 
 * 3.DNS域名解析：浏览器向DNS服务器发起请求，解析该URL种域名对应的IP地址。dns服务器使基于
 * UDP的，因此会用到UDP协议。
 * 4.建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接
 * 5.发起HTTP请求：浏览器发起读取文件的HTTP请求，该请求报文作为TCP三次握手的第三次数据发送
 * 给服务器
 * 6.服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
 * 7.关闭TCP连接：通过四次挥手释放TCP连接
 * 8.浏览器渲染：客户端（浏览器）解析html内容并渲染出来，浏览器接收到数据包后的解析流程为：
 * ·构建DOM树：此法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是
 * document对象
 * ·构建css规则树：生成css规则树（css Rule Tree）
 * ·构建render树：微博浏览器将DOM和cssom结合，并构建出渲染树（render tree）
 * ·布局（layout）:计算出每个节点在屏幕中的位置
 * ·绘制（painting）：即遍历render树，并使用ui后端层绘制每个节点
 * 
 * 9。js引擎解析过程：调用js引擎执行js代码（js的解释阶段，预处理阶段，执行阶段生成执行
 * 上下文，vo，作用域链，回收机制等等）
 * ·创建weindow对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量
 * 和函数都属于window的属性和方法，而DOM tree也会映射在window的document对象上。
 * 当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
 * ·加载文件：完成js引擎分析它的语法域词法是否合法，如果合法进入预编译
 * ·预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window
 * 对象中，并给变量赋值为undefined；寻找全局函数声明，把他作为window的方法加入到window对象
 * 中，并将函数体赋值给他（匿名函数时不参与预编译的，因为它时变量）。而变量提升作为不合理
 * 的地方在ES6中已经解决，函数提升还存在。
 * ·解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在es5非严格
 * 模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就时直接
 * 把值放在存储控件里，object对象就是把指针指向变量的存储空间。函数执行九江函数的环境推入
 * 一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。js作用域其实就是这样的执行流
 * 机制实现的。
 * 
 * 浏览器重绘域重排的区别？
 * 
 * ·重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，
 * 将其安防再界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素
 * ·重回（Repaint）：当一个元素的外观发生了改变，但没有改变布局，重新把元素外观绘制出来的
 * 过程，叫做重绘，表现为某些元素的外观被改变。
 * 
 * 单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制收到
 * 此次重排影响的部分
 * 
 * 重排和重绘代价是高昂的，他们会破坏用户体验，并且让ui展示非常缓慢，而相比之下重排的性能影响
 * 更大，再两者无法避免的情况下，一般我们宁可选择代价更小的重绘
 * 
 * 重绘不一定重排，重排必然会出现重绘
 * 
 * 如何触发重排和重绘
 * 
 * 任何改变用来构建渲染树的信息都会导致一次重排或重绘；
 * ·添加、删除、更新DOM节点
 * ·通过display：none隐藏一个DOM节点-触发重排和重绘
 * ·通过visibility:hidden隐藏一个dom节点-只会触发重绘，因为没有几何变化
 * ·移动或给页面中的DOM节点添加动画
 * ·添加一个样式表，调整样式属性
 * ·用户行为，例如调整窗口大小，改变字号，或者滚动。
 * 
 * 
 * 如何避免重绘或者重排
 * 1.集中改变样式，不要一条一条地修改dom的样式
 * 2.不要把DOM节点的属性值放循环里当作循环里的变量。
 * 3.为动画的html元件使用fixed或absolute的position。那么修改他们的css是不会reflow的
 * 4.不适用table布局。因为可能很小的一个改动会造成整个table的重新布局
 * 5.尽量只修改position或者fixed元素，对其他元素影响不大。
 * 6.动画开始GPU加速，translate使用3d变化
 * 7，提升为合成层
 * 将元素提升为合成层有以下优点：
 * ·合成层的位图，会交由GPU合成，比cpu处理要快
 * ·当需要repaint时，只需要repaint本身，不会影响到其他的层
 * ·对于transform和opacity小伙不会触发layout和paint
 * 
 * 提升合成层的最好方法时使用css的will-change属性
 * #target{
 *  will-change:transform;
 * }
 * 
 * 
 * 
 * 介绍一下304过程
 * 
 * ·a。浏览器请求资源时首先命中资源的Expires和Cache-Control，Expires受限于本地时间，
 * 如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control：max-age指定最大生命
 * 周期，状态仍然返回200，但不会请求数据，再浏览器中能明显看到from cache字样
 * b。强缓存失效，进入协商缓存阶段，首先验证ETag，ETag可以保证每一个资源时唯一的，资源
 * 变化都会导致ETag变化。服务器根据客户端上发送的If-None-Match值来判断是否命中缓存
 * c。协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务器返回的
 * header中会加上Last-Modify，Last-modify时一个时间标识该资源的最后修改时间。再次请求
 * 该资源时，request的请求头中会包含If-Modify-Since,该值为缓存之前返回的Last-Modify。
 * 服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。
 * 
 * 浏览器的缓存机制 强制缓存 && 协商缓存
 * 
 * 浏览器于服务器通信的方式为应答模式，即是：浏览器发起HTTP请求-服务器响应该请求。那么
 * 浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定
 * 是否缓存结果，是，则将请求结果和缓存标识存入浏览器缓存中，
 * 
 * 由上图我们可以知道：
 * ·浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
 * ·浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存
 * 
 * 以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入于读取，只要我们再
 * 理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要
 * 向服务器重新发起http请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。
 * 
 * ·强制缓存
 * 强制缓存就是向浏览器缓存查找该请求结果，并根据结果的缓存规则来决定是否使用该缓存结果的
 * 过程。当浏览器向服务器发起请求时，服务器回将缓存规则放入HTTP响应报文的HTTP头中和请求结果
 * 一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control
 * 优先级比Expires高。
 * 
 * 强制缓存的情况主要有三种（暂不分析协商缓存过程），如下：
 * 1.不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
 * 2.存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
 * 3.存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果。
 * 
 * ·协商缓存
 * 
 * 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识
 * 决定是否使用缓存的过程。同样，协商缓存的标识也是再响应报文的HTTP头中和请求结果一起
 * 返回给浏览器的，控制协商缓存的字段分别由：Last-modified/If-Modified-Since和Etag/
 * If-None-match，其中Etag/If-None-match的优先级比Last-Modified/If-Modified-Since高
 * 协商缓存主要由以下两种情况：
 * 1.协商缓存生效，返回304
 * 2.协商缓存失效，返回20-0和请求结果
 * 
 * 
 * 说一下进程、线程和协程
 * 
 * 进程是一个具有一定独立功能的程序再一个数据集上的一次动态执行的过程。是操作系统进行
 * 资源分配和调度的一个单例单位，是引用程序运行的载体，进程是一种抽象的概念，从来没有
 * 同意的标准定义。
 * 
 * 线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派
 * 的基本单位。一个进程可以由一个或多个线程，各个线程之间共享程序的内存空间（也就是所在
 * 进程的内存空间）。一个标准的线程由线程ID、当前指令指针（pc）、寄存器和堆栈组成。而
 * 进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。
 * 
 * 协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员
 * 自己来管理的轻量级线程叫做【用户空间线程】，具有对内核来说不可见的特性。
 * 
 * 进程和线程的区别
 * 
 * 【区别】
 * 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
 * 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
 * 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
 * 系统开销：再创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于
 * 创建和撤销线程时的开销。但是进程由独立的地址空间，一个进程崩溃后，再保护模式下不会对
 * 其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但
 * 线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比
 * 多线程的程序击安装，但再进程切换时，耗费资源较大，效率要差一些。
 * 
 * 【联系】
 * 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
 * 资源分配给进程，同一进程的所有线程共享该进程的所有资源；
 * 处理机分给线程，即真正的处理机上运行的是线程
 * 线程再执行过程中，需要写作同步，不同进程的线程间要利用消息通信的办法实现同步。
 * 
 * BFC(块级格式上下文)
 * 
 * BFC的概念
 * 
 * BFC是Block Formatting Context的缩写，即块级格式化上下文。BFC是css布局的一个概念，
 * 是一个独立的渲染区域，规定了内部box如何布局，并且这个区域的子元素不会影响到外面的
 * 元素，其中比较重要的布局规则有内部box垂直放置，计算BFC的高度的时候，浮动元素也参与
 * 计算
 * 
 * BFC的原理布局规则
 * 
 * ·内部的Box会在垂直方向，一个接一个地放置
 * ·Box垂直方向的距离由margin决定。同属于一个BFC的两个相邻Box的margin会发生重叠
 * ·每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格式化
 * 否则相反）
 * ·BFC的区域不会与float box重叠
 * ·BFC是一个独立容器，容器里面的子元素不会影响到外面的元素
 * ·计算BFC的高度时，浮动元素也参与计算高度
 * ·元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的Formatting context。
 * 
 * 如何创建BFC？
 * ·根元素，即html元素
 * ·float的值部位none；
 * ·position为absolute或fixed
 * ·display的值为Inlline-block、table-cell、table-caption
 * ·overflow的值不为visible
 * 
 * BFC的使用场景
 * ·去除边距重叠现象
 * ·清除浮动（让父元素的高度包含子浮动元素）
 * ·避免某元素被浮动元素覆盖
 * ·避免多列布局由于宽度计算四舍五入而自动换行
 * 
 * js 垃圾回收机制
 * 
 * 1.项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些
 * 代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。
 * 
 * 2.浏览器垃圾回收机制/内存回收机制
 * 
 * 浏览器的js具有自动垃圾回收机制（GC:Garbage Collecation），垃圾收集器会定期
 * （周期性）找出那些不在继续使用的变量，然后释放其内存
 * 
 * 标记清除：在js中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入
 * 环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并
 * 回收他们所占用的内存空间。
 * 
 * 谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会
 * 回收它；如果被占用了，就不能回收。
 * 
 * ie浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减一次，减到0时，
 * 浏览器就回收它。
 * 
 * 3.优化手段：内存优化；手动释放：取消内存的占用即可。
 * 1》堆内存：fn = null [null：空指针对象]
 * 2》栈内存：把上下文中，被外部占用的堆的占用取消即可
 * 
 * 4.内存泄漏
 * 在js中，常见的内存泄漏主要有4中，全局变量、闭包、DOM元素引用、定时器
 * 
 * 
 * 作用域和作用域链
 * 
 * 创建函数的时候，已经声明了当前函数的作用域==》当前创建函数所处的上下文。如果是在全局
 * 下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文EC(FN)，
 * 供字符串代码执行（进栈执行）
 * 
 * 定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象
 * 组成。
 * 1.全局作用域：代码在程序的任何地方都能被访问，window对象的内置属性都拥有全局作用域。
 * 2.函数作用域：在固定的代码片段才能被访问
 * 
 * 作用：作用域最大的用处就是 隔离变量，不同作用域下同名变量不会由冲突。
 * 
 * 一般情况下，变量到创建该变量的函数的作用域中取值。但是如果在当前作用域中没有查到，就会
 * 向上一级作用域去查，知道查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
 * 
 * 
 * 闭包的两大作用：保存/保护
 * 
 * ·闭包的概念
 * 
 * 函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放；但是特殊情况下
 * 如果当前私有上下文中的某个东西被上下文意外的事物占用了，则上下文不会出栈释放，从而
 * 形成不销毁的上下文。函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会
 * 被释放，不论释放与否，它的作用是：
 * 1.保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储空间，保护自己的私有
 * 变量不受外界干扰（操作自己的私有变量和外界没有关系）
 * 
 * 2.保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有
 * 变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来。
 * 
 * 我们把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。
 * 
 * 
 * 稍全面的回答：在js中变量的作用域属于函数作用域，在函数执行完后，作用域就会被清理，内存
 * 也会随之被回收，但是由于闭包函数是建立在函数内部的子函数，由于其可访问上级作用域，即使
 * 上级函数执行完，作用域也不会随之销毁，这时的子函数（也就是闭包），便拥有了访问上级作用
 * 域中变量的权限，即使上级函数执行完后作用域内的值也不会被销毁
 * 
 * ·闭包的特性：
 * 1.内部函数可以访问定义他们外部函数的参数和变量（作用域链的向上查找，把外围的作用域中的
 * 变量值存储在内存中而不是在函数调用完毕后销毁）设计私有的方法和变量，避免全局变量的污染。
 * 1.1闭包是密闭的容器，类似于set、map容器，存储数据的
 * 1.2闭包是一个对象，存放视具的格式为key-value形式
 * 2.函数嵌套函数
 * 3.本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量始终保存在内存
 * 中，不会再函数被调用之后自动清除。
 * 
 * ·闭包形成的条件
 * 1.函数的嵌套
 * 2.内部函数引用外部函数的局部变量，延长外部函数的变量声明周期
 * 
 * ·闭包的用途
 * 1.模块块级作用域
 * 2.保护外部函数的变量 能够访问函数定义时所在的词法作用域（阻止其被回收）
 * 3.封装私有化变量
 * 4.创建模块
 * 
 * ·闭包应用场景
 * 
 * 闭包的两个场景，闭包的两大作用：保存/保护。再开发中，其实我们随处可见闭包的身影，大部分
 * 前端js代码都是“事件驱动”的，即一个事件绑定的回调方法；发送ajax请求成功|失败的回调；
 * setTimeout的延时回调；或者一个函数内部返回另一个匿名函数，这些都是闭包的应用。
 * 
 * ·闭包的优点：延长局部变量的声明周期
 * 
 * ·闭包的缺点：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏
 * 
 * 原型 && 原型链
 * 
 * 原型关系：
 * ·每个class都有显示原型prototype
 * ·每个实例都有隐式原型__proto__
 * ·实例的__proto__指向对应class的prototype
 * 
 * 
 * 
 * 
 * 
 * 
 */

/* //动态创建script
var script = document.createElement('script')

//设置回调函数
function getData(data) {
  console.log(data)
  eval(data)
}

//设置script的src属性，并设置请求地址
script.src = 'http://localhost:8888/aa?callback=getData'

//让script生效
document.body.appendChild(script) */