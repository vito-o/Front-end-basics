/**
 * HTTP请求从发起到接收一共经历了如下八个阶段：
 * 构建请求、查找缓存、准备ip和端口、等待TCP队列、建立TCP连接、发起http请求、服务器处理请求、服务器返回请求和断开连接
 * ---------------------------------------------------------------------------------------------------------------------
 * 浏览器进程：
 *    用户输入 ->处理输入信息 -> 开始导航      重定向             准备渲染进程    确认文档被提交                  页面完成加载
 *                                    |         |              |        |       |                               | 
 * 网络进程：                          |         |                       |       |                               |
 *                                    发起url请求 - 读取响应头信息   --   |   --  | -读取响应体数据                |
 *                                                                      |       |              |               |
 * 渲染进程：                                                            |       |              |               | 
 *                                                                      提交文档              页面解析和子资源加载
 * -----------------------------------------------------------------------------------------------------------------------
 * 
 * 从图中可以看出，存在进程键的通信（IPC）
 * ·浏览器进程主要负责用户交互、子进程管理和文件存储等功能
 * ·网络进程是面向渲染进程和浏览器进程等提供网络下载功能
 * 渲染进程是把HTML、css、JavaScript、图片等资源解析为可以显示和交互的页面
 * 
 * 通常渲染进程是在安全沙箱中的，chrome这样的安全措施环视很有必要的，你可以理解成渲染进程中所有的内容都是通过网络获取的，可能这个过程中存在一些
 * 恶意代码，这类代码利用浏览器漏洞对系统进行攻击，所以就很有必要。
 * 
 * 通过上面的图片，这个过程大致如下：
 * 
 * 1.浏览器进程发出url请求给网络进程
 * 2.网络进程接收到url请求后，发起网络请求，然后服务器返回http数据到网络进程，网络进程解析http响应头数据，并将其转发给浏览器进程
 * 3.浏览器进程接收到网络进程的响应头数据后，发送CommitNavigation消息到渲染进程，发送CommitNaviagtion时会携带响应头、等基本信息
 * 4.渲染进程接收到CommitNavigation消息后，便开始准备接收html数据，接收数据的方式是直接和网络进程建立数据管道
 * 5.最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程，说我已经准备好接收和解析页面数据了
 * 6.最后浏览器进程更新了页面状态
 * 
 * 尝试分析整个流程
 * 
 * 1.用户输入url
 * 
 * 浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的url；如果用户输入的内容符合url规则，浏览器就会根据url协议，
 * 再这段内容上加上协议合成合法的url
 * 
 * 比如输入www.baidu.com地址栏会根据规则，把这段内容加上协议，合成完整的url，如https://www.baidu.com
 * 
 * 用户输入完内容，按下回车键，浏览器导航显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得。
 * 
 * 当然这里的话，有一个beforeupload事件，改事件允许页面退出前执行一些数据的清理操作，还可以询问用户是否要离开当前页面，比如当前页面有未提交的表单，
 * 用户还可以通过beforeupload事件来取消导航，让浏览器不在进行后续工作。
 * 
 * 2.url请求过程
 * 
 * 浏览器进程将构建请求行数据，进行进程间通信（IPC）将url请求发送给网络进程，类似与下面这个：
 * GET /index.html HTTP1.1
 * 
 * 3.网络进程获取到url，先到本地缓存中查找是否有缓存文件，如果有，拦截请求，直接返回200；否则，进入网络请求过程。
 * 
 * 4.网络进程请求DNS返回域名对应的ip和端口号，如果之前dns数据缓存服务器缓存过当前域名信息，就直接返回缓存信息；否则，发起请求获取根据域名解析出来的ip和端口号，
 * 如果没有端口号，http默认80，https默认443。如果是https请求，还要建立TLS连接。
 * 
 * 5.在进程TCP连接的过程中，Chrome有个机制，同一个域名下最多只能建立6个TCP连接。如果在同一个域名下有10个请求发生。那么其他4个请求会进入等待状态，直到进行中
 * 的请求完成。如果请求个数小于66，直接建立TCP连接。
 * 
 * 6.TCP三次握手建立连接，http请求加上TCP头部--包括源端口号、目的端口号和用于校验数据完整性的序号，向下传输。
 * 
 * 7.网络层在数据包上加上ip头部---包括源ip地址和目的ip地址，继续向下传输到底层
 * 
 * 8、登场通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出ip头部，识别出数据部分，将解开的数据包向上传输到传输层。
 * 
 * 9.目的服务器主机传输层获取到数据包，解析出tcp头部，识别端口，将解开的数据包向上传输到应用层。
 * 
 * 10.应用层http解析请求头和请求体，如果需要重定向，http直接返回http响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据
 * code和Location进行重定向操作；如果不是重定向，首先服务器会根据请求头中的if-None-Match的值来判断请求的资源是否被更新；如果没有更新，就返回304状态码，
 * 相当于告诉浏览器之前的缓存还可以使用，就不反悔新数据了；否则，返回新数据，200的状态，并且如果想要浏览器缓存数据的话，就在相应的头部加上字段
 * Cache-Cotrol:Max-age=2000
 * 响应数据又顺着应用层-传输层-网络层 -- 网络层-传输层 -应用层的顺序返回到了网络进程。
 * 
 * 11.数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在http头部加上如下信息，TCP就一直保持连接。保持TCP连接就可以省下建立连接的事件，提升资源加载
 * 速度。
 * Connection:Keep-Alive
 * 
 * 12.网络进程将获取到的数据包进行解析，根据响应头中的Content-Type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器；如果是text/html类型，就
 * 通知浏览器进程获取到文档准备渲染。
 * 
 * content-type：application/octet-stream 告诉浏览器返回的数据是字节流类型，通常情况下，浏览器会按照下载类型来处理
 * content-type: text/html 告诉浏览器返回的是HTML格式内容
 * 
 * 从返回的响应头信息来看，其Content-Type的值是application/octet-stream,显示数据是字节流类型，通常情况下，浏览器会按照下载类型来处理该请求
 * 
 * 需要注意的是，如果服务器配置Content-Type不正确，比如将text/html类型配置成application/octet-stream类型，那么浏览器可能会曲解文件内容，比如
 * 会将一个本来是用来展示的页面，变成一个下载文件。
 * 
 * 13.浏览器进程获取到通知，根据当前页面b是否是从页面a打开的并且和页面a是否是同一个站点(根域名和协议一样就被认为是同一个站点)，如果满足上述条件，就复用
 * 之前网页的进程，否则，新创建一个单独的渲染进程。
 * 
 * 14.浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息
 * 给浏览器进程。
 * 
 * 15.浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括安全状态、地址栏url、前进后退的历史状态，并更新web页面，此时web页面时空白的。
 * 
 * 这也就解释了为什么浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。
 * 
 * 16.渲染进程对文档进行页面解析和子资源加载，html通过html解析器转成DOM tree,css按照css规则和css解析器转成CSSOM tree，两者结合，形成render tree（
 * 不包含html的具体元素和元素要画的具体位置），通过layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。
 * 
 * 导航流程很重要，他是网络加载流程和渲染流程之间的一座桥梁，你能理解导航流程，那么你就能完整串起来整个页面显示流程，这对于理解浏览器的工作原理起到了点睛
 * 作用。
 *  
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 
 * 渲染流程
 * 
 * 首先要了解的概念：
 * 渲染引擎：他是浏览器最核心的部分"Rendering Engine",不过我们一般习惯将之称为“浏览器内核”
 * 
 * 渲染引擎（渲染进程）主要包括的线程：
 * 1.GUI渲染线程
 * 2.javascript引擎线程
 * 3.事件触发线程
 * 4.定时触发器线程
 * 5.http异步请求线程
 * 
 * 各个线程的主要职责：
 * 1.GUI渲染线程
 * GUI渲染线程负责渲染浏览器界面，解析html、css，构建DOM树和RenderObject树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，
 * 该线程就会执行。
 * 
 * 2.javascript引擎线程
 * javascript引擎线程主要负责解析javascript脚本并运行相关代码。
 * javascript引擎在一个tab页面（Renderer进程）中无论什么时候都只有一个javascript线程运行javascript程序。需要提起的一点是，GUI线程与javascript线程
 * 是互斥的。这也就是为什么javascript操作时间过长会造成页面渲染不连贯，导致页面出现阻塞的原理。
 * 
 * 事件触发线程：
 * 当一个事件被触发时该线程会把事件添加到待处理队列的队尾。等待javascript引擎的处理。通常javascript是单线程的，所以这些事件都会排队等待js执行
 * 
 * 定时器触发器：
 * 我们日常使用的setInterval和setTimeout就在该线程中，原因可能就是：由于js引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性，所以需要通过单独
 * 线程来计时并触发响应的事件这样子更为合理。
 * 
 * HTTP请求线程：在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，这个线程就是http请求线程，它将检测到状态变更时，如果设置有回调函数，异步线程
 * 就产生状态变更事件到javascript引擎的处理队列中等待处理。
 * 
 * 简略版的渲染机制
 * 
 * 分为以下步骤：
 * 1.处理html并构建DOM树
 * 2.处理css构建cssom树
 * 3.将dom与cssom合并成一个渲染树
 * 4.根据渲染树来布局，计算每个节点的位置
 * 5.调用GPU绘制，合成图层，显示在屏幕上。
 * 
 * 接下来大概就这么说：
 * 在构建cssom树时，会阻塞渲染，直至cssom树构建完成。并且构建cssom树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过渡层叠，越是具体的css选择器，
 * 执行速度越慢。
 * 
 * 当html解析到script标签时，会暂停构建DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载js文件。并且css也会
 * 影响js的执行，只有当解析完样式表才会执行js，所以也可以认为这种情况下css也会暂停构建DOM。
 * 
 * Load和DOMContentLoaded区别
 * 
 * Load事件触发代表页面中的DOM，css，js，图片已经全部加载完成
 * 
 * DOMContentLoaded事件触发代表初始的html被完成加载和解析，不需要等待css，js，图片加载
 * 
 * 图层
 * 
 * 一般来说，可以把普通文档看成一个图层。特定的属性可以生成一个新的图层。突通的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个图层，提高性能。
 * 但也不能生成过多的图层，会引起反作用。
 * 
 * 通过以下几个常用属性可以生成新图层
 * ·3d变换：translate3d、translateZ
 * ·will-change
 * ·video、iframe标签
 * ·通过动画实现的opacity动画转换
 * ·position：fixed
 * 
 * 重绘（Repaint）和（Reflow）
 * 
 * 重绘和回流是渲染步骤中的一个小节点，但是这两个步骤对于性能影响很大。
 * ·重绘是当节点需要改变外观而不会影响布局，比如改变color就叫做重绘
 * ·回流是布局或者几何属性需要改变就成为回流
 * 
 * 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高得多，改变深层次得节点很可能导致父节点得一系列回流。
 * 
 * 所以以下几个动作可能会导致性能问题：
 * ·改变window大小
 * ·改变字体
 * ·添加或 删除样式
 * ·文字改变
 * ·定位或浮动
 * ·盒模型
 * 
 * 很多人不知道得是，重绘和回流其实和Event Loop有关
 * 1.当Event loop执行完Microtasks后，会判断document是否需要更新。因为浏览器是60Hz的刷新频率，每16ms更新一次
 * 2.然后判断是否有resize或者scroll，有的话会去触发事件，所以resize和scroll事件也是至少16ms才会触发一次，并且自带节流功能。
 * 3.判断是否触发了media query
 * 4.更新动画并且发送事件
 * 5.判断是否有全屏操作事件
 * 6.执行requestAnimationFrame回调
 * 7.执行IntersectionObserver回调，该方法用于判断元素是否可见，可用于懒加载，但是兼容性不好。
 * 8.更新界面
 * 9.以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行reequestIdleCallback回调。
 * 
 * 
 * 减少重绘和回流
 * ·使用translate替代top //document.querySelector('.root').style.translate = '140px 29px'
 * ·使用visibility替换display:none; 因为前者会引起重绘，后者会引起回流（改变布局）
 * ·把DOM离线后修改，比如：先把dom给display:none;（只有一次Reflow），然后你修改100次，然后再把它显示出来
 * ·不要把DOM节点的属性值放在一个循环里当成循环变量
 * for(let i = 0; i < 1000; i++) {
 *    //获取offsetTop会导致回流，因为需要去获取正确的值
 *    console.log(document.querySelector('.test').style.offsetTop)
 * }
 * ·不要使用table布局，可能很小的一个改动会造成整个table的重新布局
 * ·动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrame
 * ·css选择符从右往左匹配查找，皮面DOM深度过深
 * ·将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于video标签，浏览器会自动将该节点变为图层。
 * 
 * 
 * 详细版的渲染机制
 * 
 * 较为专业的属于总结为以下阶段
 * 1.构建DOM树
 * 2.样式计算
 * 3.布局阶段
 * 4.分层
 * 5.绘制
 * 6.分块
 * 7.光栅化
 * 8.合成
 * 
 * 
 * 可以想象以下，从0，1字节到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程化为很多个子阶段，渲染引擎从网络进程拿到字节
 * 流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以成为渲染流水线。
 * ------------------------------------------------------------------------
 * 
 * 构建DOM树
 * 
 * 这个过程主要工作就是将html内容转换为浏览器dom树解构
 * 字节 -> 字符 -> 令牌 -> 节点 -> 对象模型（DOM）
 * 
 * 字节bytes 3c 62 6f
 * 字符characters <html><head>....
 * 令牌Tokens StartTag: html StartTag: head ... EndTag: head...
 * 节点Nodes html、head、meta、body、p
 * DOM(树型结构)
 * 
 * 大概过程：
 * 1.转换：浏览器从磁盘或者网络读取HTML原始字节，并根据文件的指定编码（例如UTF-8）将它们转换成各个字符。
 * 2.令牌化：浏览器将字符串转换成W3C HTML5标准规定的各种令牌，例如html、head以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。
 * 3.词法分析：发出的令牌转换成定义其属性和规则的“对象”
 * 4.DOM构建：最后，由于html标记定义不同标记之间的关系（一些标记包括在其他标记内），创建的对象连接在一个树数据结构内，此结构也会捕获原始标记中
 * 定义的父项-子项关系：html对象是body对象的父项，body是paragraph对象的父项。
 * 
 * 我们把上述这样子的过程叫做是构建DOM过程
 * 
 * 
 * 样式计算
 * 
 * 这个子阶段有三个步骤
 * ·格式化样式表
 * ·标准化样式表
 * ·计算每个DOM节点具体样式
 * 
 * 格式化样式表
 * 我们拿到的也就是0，1字节流数据，浏览器无法直接去识别，所以渲染引擎收到css文本数据后，会执行一个操作，转换为浏览器可以理解的结构-styleSheets
 * 
 * 通过浏览器的控制台document.styleSheets可以来查看这个最终结果，通过javascript可以完成查询和修改功能，或者说这个阶段为后面的样式操作提供基石
 * 
 * 标准化样式表
 * 什么是标准化样式表呢？先看一段css文本
 * body{font-size:2em}
 * p{color:blue}
 * span {display:none}
 * 
 * 有些时候，我们写css样式的时候，会写font-size:2em;color:red;font-weight:blod;像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将他们
 * 标准化，如em->px, red -> rgba(255,0,0,0),blod -> 700等等。
 * 
 * 计算每个DOM节点的具体样式
 * 
 * 通过格式化和标准化，接下来就是计算每个节点具体样式信息了。
 * 计算规则：继承和层叠
 * 
 * 继承：每个子节点会默认继承父节点的样式，如果父节点中找不到，就会采用浏览器默认样式，也叫UserAgent样式。
 * 层叠：样式层叠，是css一个基本特征，他定义如何合并来自多个源的属性值的算法。某种意义上，它处于核心地位，具体的层叠规则属于深入css语言的规范，这里
 * 就不展开了。
 * 
 * 不过值得注意的是，在计算完样式之后，所有的样式值会被挂到window.getComputedStyle当中，也就是可以通过js来获取计算后的样式，非常方便
 * window.getComputedStyle(document.querySelector('.root'))
 * 
 * 这个阶段，完成了Dom节点中每个元素的具体样式，计算过程中要遵循css的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在ComputedStyle中
 * 
 * 另一种说法cssom
 * 
 * 如果不是很理解的话
 * Bytes -> Characters -> Tokens -> Nodes -> CSSOM
 * 
 * 跟处理html一样，我们需要根据css两个规则继承和层叠转换成某种浏览器能理解和处理的东西，处理过程类似处理html。
 * 
 * css字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“css对象模型（cssom）”的树形结构内
 * 
 * 和DOM不一样，源码中并没有cssom这个词，所以很多文章说的cssom应该就是styleSheets，当然了这个styleSheets我们可以打印出来
 * 很多文章说法是渲染树也是16年前的说法，现在代码重构了，我们可以吧LayoutTree堪称是渲染树不过他们之间还是有些区别的。
 * 
 * 生成布局树
 * 
 * 上述过程已经完成DOM树（Dom）构建，以及样式计算（DOM样式），接下来就是要通过浏览器的布局系统确定元素位置，也就是生成一颗布局树（LayoutTree）之前叫做渲染树。
 * 
 * 创建布局树
 * 
 * 1.在DOM树上不可见的元素，head元素，meta元素等等，以及使用display：none；属性的元素，最后都不会出现在布局树上，所以浏览器布局系统需要额外去构建一颗
 * 只包含可见元素布局树。
 * 2.我们直接结合图来看看这个布局树构建过程：
 * 
 * 为了构建布局树，浏览器布局系统大体完成了上面这些工作：
 * ·遍历DOM树可见节点，并把这些节点加到布局树中
 * ·对不可见节点，head，meta标签等都会被忽略。对于body.p.span这个元素，它的属性包含display:none;所以这个元素没有被包含进布局树。
 * 
 * 布局计算
 * 
 * 接下来就是要计算布局树节点的坐标位置，布局的计算过程非常复杂，我们只需要知道它所做的工作是什么，想知道它是如何做的，可以看以下文章。
 * 
 * 梳理前三个阶段
 * 
 * 构建DOM ： 1.标记化  2.建树算法
 * 样式计算：  1.格式化  2.标准化  3.计算规则：继承、层叠
 * 生成布局树
 * 
 * 分层
 * 1.生成图层树（layout Tree）
 * 2.拥有层叠上下文属性的元素龟背提升为单独一层
 * 3.需要裁剪（clip）的地方也会被创建图层
 * 4.图层绘制
 * 
 * 首先需要知道的就是，浏览器在构建完布局树后，还需要进行一系列操作，这样子可能考虑到一些复杂场景，比如一些复杂的3D变换、页面滚动、或者使用z-index做
 * z轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。
 * 
 * 生成图层树
 * 
 * 你最终看到的页面，就是由这些图层一起叠加构成的，他们按照一定的顺序叠加在一起，就形成了最终的页面。
 * 
 * 浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
 * 
 * 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
 * 那么什么情况下，渲染引擎回味特定的节点创建新图层呢？
 * 有两种情况需要分别讨论，一种是显式合成，一种是隐式合成。
 * 
 * 显式合成
 * 
 * 一、拥有层叠上下文的节点
 * 
 * 层叠上下文也基本上就是一些特定的css属性创建的，一般有以下情况：
 * 1.html根元素本身就具有层叠上下文
 * 2.不同元素设置position不为static并且设置了z-index属性，会产生层叠上下文。
 * 3.元素的opacity不是1
 * 4.元素的transform值不是none
 * 5.元素的filter值不是none；
 * 6.元素的isolation值是isolate
 * 7.will-change指定的属性值为上面任意一个
 * 
 * 二、需要裁剪（clip）的地方
 * 
 * 比如一个标签很小，50*50像素，你在里面放了非常多文字，那么超出的文字部分就需要被裁剪，当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层。
 * 
 * 元素有了层叠上下文的属性或者需要被裁剪，满足其中任意一点，就会被提升为单独一层。
 * 
 * 隐式合成
 * 
 * 这是一种什么样的情况呢？通俗意义上来说，就是z-index比较低的节点会提升为一个到单独的图层，那么层叠等级比他高的节点都会成为独立图层。
 * 缺点：根据上面的文字来说，在一个大型项目中，一个z-index比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，
 * 上千个图层，会增大内存的压力，有时候会让页面奔溃。这就是层爆炸。
 * 
 * 绘制
 * 
 * 完成一个图层的构建，接下来要做的工作就是图层的绘制了。图层的绘制跟我们日常绘制一样，每次都会把一个复杂的图层拆分为很小的绘制指令，然后再
 * 按照这些指令的顺序组成一个绘制列表，
 * 
 * 从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色线条等。二绘制一个元素通常需要好几条绘制指令
 * 因为每个元素的背景、前景、边框、都需要单独的指令去绘制
 * 
 * 当然，绘制图层的操作在渲染进程中有着专门的线程，这个线程叫做合成线程。
 * 
 * 分块
 * 
 * 接下来我们要开始绘制操作了，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫做合成线程。
 * 绘制列表准备好之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候
 * 
 * 你想呀，有时候，你的图层很大，或者你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这时候需要滚动好久才能滚动到底部，但是通过视口，
 * 用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的化，就会产生太大的开销，而且没有必要。
 * 
 * 基于上面的原因，合成线程会将图层划分为图块（tile）
 * 这些快的大小一般不会特别大，通常是256*256或者512*512这样的规格，这样可以大大加速页面的首屏展示。
 * 
 * 首屏渲染加速可以这么理解：
 * 
 * 因为后面图块（非视口内的图块）数据要进入GPU内存，考虑到浏览器内存上传到gpu内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对
 * 这个问题，chrome采用了一个策略；在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续合成操作，
 * 当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换，这也是chrome底层优化首屏加载速度的一个手段。
 * 
 * 光栅化
 * 
 * 接着上面的步骤，有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作时由栅格化来执行的。所谓栅格化，是指将图块转换为位图。
 * 
 * 图块是栅格化执行的最小单位
 * 渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据
 * 合成线程会选择视口附近的图块（tile），把他交给栅格化线程池生成位图
 * 生成位图的过程实际上都会使用GPU进行加速，生成的位图最后发送给合成线程
 * 
 * 通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。
 * 
 * 想象你还记得，GPU操作时运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作
 * 
 * 渲染进程把生成图块的指令发送给GPU，然后在GPU中执行生成图块的位图，并保存在GPU的内存中。
 * 
 * 合成和显示
 * 
 * 栅格化完成后，合成线程会生成一个绘制命令，即“DrawQuad”，并发送给浏览器进程
 * 浏览器进程中的viz组件接收到这个指令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。
 * 
 * 显示器显示图像的原理解释：
 * 无论pc显示器还时手机显示器，都有一个固定的刷新频率，一般时60hz，即60帧，也就是一秒更新60张图片，一张图片停留的时间约为16.7ms。而每次更新的图片都
 * 来自显卡的前缓冲区。而显卡接收到浏览器进程传过来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此
 * 循环更新。
 * 
 * 这个时候，心中就有点概念了，比如某个动画大量占用内存时，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的评论刷新，
 * 因此会出现卡顿，也就是明显的掉帧现象。
 * 
 */