/**
 * 现代浏览器内部机制 part1 | 多进程架构
 * 
 * CPU和GPU
 * 为了更好的了解浏览器的运行环境，我们首先需要知道几个计算机的构成部分以及他们分别
 * 是做什么的。
 * 
 * cpu
 * 首先要知道的概念是中央处理器，也就是我们常说的cpu。
 * cpu可以看作是整个计算机的大脑。在上面这张图中，一个CPU核被比喻成了一个工位上的
 * 社畜，当有不同的任务传递进来时，它可以一个一个的去处理这些任务。当cpu知道如何响应
 * 人们的需求时，它几乎可以处理各式各样的任务，比如数学，或是艺术。在早些年，cpu都是
 * 有单芯片所构成。每个核就像是在芯片中又存在着另一个cpu。现代的电子设备基本上都是
 * 多核驱动的，这让人们的手机核电脑都具有了更强的计算能力。
 * 
 * GPU
 * 
 * 我们需要了解的另一部分，就是图形处理器，也就是GPU
 * 和cpu不同的是，GPU擅长同时处理跨多核的简单任务。正如它的名字，在设计之初就是用来
 * 处理图形的。这也正是为什么当图形任务的处理和GPU关联起来的时候，通常带来的都是
 * 更快速的渲染和更流畅的交互。近年来，随着GPU的不断加速和升级，越来越多的计算都
 * 可能直接被放在GPU上进行了。
 * 当你在手机或电脑上启动一个应用时，CPU和GPU就是为那个应用提供“能量”的两个小兄弟
 * 通常，应用程序通过操作系统提供的“机制”在cpu和gpu上运行。
 * 
 * 在交接浏览器架构之前，我们还需要了解进程和线程。
 * 进程可以描述为一个应用程序的执行程序，线程则是进程内部用来执行某个部分的程序。
 * 当你启动一个引用时，一个进程就被创建了，程序可能会创建一些线程帮助它完成某些工作，
 * 但这不是必须的。操作系统会划分出一部分内存给这个进程，当前应用程序的所有状态都将
 * 保存在这个私有的内存空间中。当你关闭应用时，进程也就自动蒸发掉了，操作系统会将先前
 * 被占用的内存空间释放掉。
 * 
 * 进程可以让操作系统再另起一个进程去处理不同的任务。当这种情况发生时，新的进程又将
 * 占据一块内存空间。当两个进程需要通信时，他们可以用一个叫做进程间通讯的办法解决。
 * 许多应用程序都被设计成这种方式进行，所以当其中一个进程挂掉时，它可以在其他进程
 * 仍然运行的时候直接重启。
 * 
 * 浏览器架构
 * 
 * 所以浏览器时如何通过进程和线程建立起来的呢？有时会是一个进程和多个不同的线程，或是
 * 多个进程和少数线程。
 * 
 * 这里要注意的一点是，这些不同的体系架构是实现上的细节，至今没有任何一个规范去限制
 * 浏览器应该被做成什么样子，不同的浏览器之间的架构可能完全不同。
 * 
 * 在这个系列中，我们以Chrome的最新架构为准。
 * 
 * 首先是浏览器的自身进程，它负责与其他进程协作，主要负责浏览器应用的不同部分，如
 * 网络、内存（At the top is the browser process coordinating with other processes
 * that take care of different parts of the appliaction）。至于渲染进程，浏览器
 * 会为每个窗口分配一个渲染进程。在最近的一次更新中，如果够用的话，chrome干脆给每个
 * 窗口分配了一个进程；二限制，chrome在致力于给每个站点一个独立的进程，包括iframe 
 * 每个进程都负责些啥？
 * 
 * 浏览器进程：负责chrome的浏览器功能，包括导航栏、书签、后退、前进按钮。当然也负责
 * 一些虽然看不到但也很重要的部分，比如网络请求和文件访问。
 * 渲染进程：窗口内的网站将如何呈现
 * 插件进程：控制着网站可能用到的所有插件，比如flash
 * GPU进程：处理GPU任务，与其他进程隔离。他被划分为不同的进程因为GPU会处理来自多个
 * 应用程序的请求并将其绘制在同一个平面上。
 * 
 * 实际上还会有更多的进程，比如扩展进程和工具进程。如果你想看Chrome到底会启动多少个
 * 进程，打开右上角的菜单，更多工具，接着选择‘任务管理器’。这将会打开一个新的窗口，
 * 里面是当前正在运行的进程列表，并且会直观的告诉你目前占用了多少cpu和内存
 * 
 * chrome多进程架构的好处
 * 之前有提到，chrome用的是多进程的渲染方式，最容易想到的场景就是每个窗口（tab）都有
 * 一个独立的渲染进程。假设你打开了三个浏览器窗口，当其中一个窗口因为某种原因崩掉了的
 * 时候，你大可以直接关闭这个不再响应的窗口并继续你在其他窗口的工作。我们换一个浏览器，
 * 所有的窗口都共享一个进程，当一个窗口挂掉的时候，所有的窗口都直接挂掉了（像不像
 * 理财的时候人们总是说：不要把所有的前放在同一个钱包里）。
 * 
 * 将浏览器的工作拆分成不同的进程换有一个好处，就是安全。由于操作系统提供了一种限制
 * 进程“权限”的方法，因此浏览器可以将特定的功能和进程有效的隔离开。比如，chrome会
 * 限制用来处理用户输入的渲染进程去直接访问文件。
 * 
 * 每个进程都有各自的内存空间，因此他们常会各自拥有一份基础功能的拷贝。正因为他们之间
 * 不像同一进程中的线程那样能够共享资源，所有就需要更多的内存占用。为了节省内存，chrome
 * 对其自身可调用的进程在数量上做了限制，具体的限制大小在不同性能的机器上各不相同，唯一
 * 确定的是，当达到了这个上限后，chrome回将同站点的多个窗口交给同一个进程来管理。
 * 
 * chrome服务化--节省更多内存
 * 浏览器进程也应用了相同的方案。chrome正在进行架构层面整改，目的是将浏览器的各部分
 * 功能变成独立的服务，这也就能轻松的将其拆分为不同的进程，也能更加灵活的互相组合。
 * 
 * 总的来说，当chrome在较高性能的设备上运行时，他会将每个服务分配至不同的进程，以此
 * 来获得更强的运行时稳定性和健壮性；反之，如果chrome运行在一台资源受限的设备上时，
 * chrome回将服务整合在一个进程中，以此来节省内存的占用。像这种通过整合进程资源以此
 * 来节省内存的手段，已经被用于android上了。
 * 
 * 站点隔离（site lsolation）
 * 站点隔离是chrome在其67桌面版上新增的特性，基本原则是不同的的站点各自运行自己的
 * 沙箱环境中，独享进程，并且不允许通信。我们已经讨论过每个窗口一个进程的模型，在这个
 * 模型中，浏览器允许跨站点的iframe独立进程共享不同站点之间的内存空间。早先在一个
 * 渲染进程中（窗口）同时允许a.com和b.com看起来没有什么问题，因为有同源策略，确保
 * 一个站点未经同意就无法访问其他站点的数据。绕过同源策略基本上成为了所有安全攻击的
 * 知道方针。而进程间的相互隔离是将站点分开的最佳途径
 * 
 * 经过多年的工程上的努力，如今的站点隔离已经默认为用户开启了。事实上，站点隔离并
 * 不仅仅是为站点分配不同的渲染进程这么简单，它从根本上改变了iframe的通信方式。打开
 * 允许有不同站点iframe的开发者工具，以为着浏览器必须做很多看不到的幕后工作，才能
 * 让这一切看起来和以前没有什么区别，即使是简简单单的ctrl+f在这个场景下也以为着在
 * 不同的渲染进程中查询字符串。网上有很多文章接收浏览器的站点隔离策略，当你看完那些
 * 之后就会意识到，为什么站点隔离值得chrome团队为其发布一个独立版本了。
 * 
 * part2 导航这件小事
 * 
 * 本文是这个系列的第二篇文章，会深入到chrome的内部。在上一篇文章中，我们了解了线程和进程在
 * 浏览器中的不同，而在这篇文章中，我们会更加深入了解当浏览器为用户呈现一个页面时，这些进程和
 * 线程之间时如何通信的。
 * 
 * 让我们以一个常见的例子作为起点：输入一个url，浏览器会从服务端获取数据并将页面展示出来。本文
 * 会聚焦在用户通过浏览器向一个站点发起访问请求以及浏览器准备渲染这个页面的部分，这个过程我称
 * 之为导航
 * 
 * 以一个浏览器进程为起点
 * 我们在上一篇文章中提过，所有处于窗口之外的部分都由同一个浏览器进程掌管。浏览器的进程又同时
 * 拥有许多线程，长官浏览器的不同部分；ui线程用来绘制顶部的操作按钮和输入框、网络线程负责处理
 * 并接收来自互联网的数据、存储线程控制着访问本地文件的权限等。当你将一个网络的url输入到浏览器
 * 的地址时，此刻正是浏览器进程中的ui线程在起作用。
 * 
 * 一次简单的导航
 * 
 * step1：处理用户输入
 * 
 * 当用户开始在地址栏输入时，ui线程首先会问：“大兄弟，你输入的时个查询字符串还时网站地址？”。
 * 因为chrome的地址栏同时还时个搜索框，所以ui线程需要解析用户输入，才能决定该直接访问网址
 * 还时把用户的输入丢给搜索引擎处理。
 * step2：开始导航
 * 当用户按下回车键后，ui线程要求网络线程去获取网站的内容。窗口的Tab上会开始转菊花，网络线程会
 * 采用一些列的协议和操作（比如DNS）查询必要的信息并未请求建立连接。
 * 此时，网络线程可能会收到来自服务器的一个标记着重定向指令的头部比如HTTP301，这种情况下，网络
 * 线程会把这件事情告诉ui线程，之后则会发起一次指向重定向地址的新网络请求。
 * step3：读取响应
 * 当响应的数据开始传送到浏览器时，网络线程会在必要的情况下检查一些来自响应的字段。响应数据的
 * Content-Type字段会表示当前返回的是哪种类型的数据，但它也不完全靠谱，进场会出现丢失或者干脆
 * 不准确的情况，但也不用担心，MIME嗅探会完成缺失的工作。正如源码的注释中写道，这是一个可被解释
 * 为hack的方案，如果感兴趣的话，你也可以去阅读这些注释，这样就能了解不同的浏览器是如何将实际
 * 的数据于Content-Type匹配了。
 * 
 * 如果响应数据是一个HTML文件，那么接下来的一步会是把数据传递给浏览器的渲染进程；但如果数据是
 * zip压缩文件或其他类型的文件，意味着这将被定位称一次下载动作，于是浏览器回将数据交给下载管理
 * 器去处理。
 * 通常这一步也是安全检测发生的时候：如果域名或响应数据和已知的恶意网站匹配时，网络进程会抛出
 * 一个警告，并展现一个告警页面。另外corb检测也会开始工作，确保那些来自敏感站点的跨站响应不会
 * 进入到浏览器渲染进程中。
 * step4：渲染进程
 * 网络线程以获取了全部的数据，并完成了所有需要的检查，此可它自信的告诉ui线程：“小兄弟，数据准备
 * 好了！”。接着，ui线程会唤起一个渲染进程去渲染页面。
 * 
 * 由于网络情况的不可控，一个请求可能会画上好几百毫秒才能把响应数据拿回来，所以这里浏览器默认
 * 开启了用来加速这一过程的优化。在step2中，当ui线程将需要请求的url告诉网络线程时，其实它本身
 * 以及知道要导航到哪个网站了，于是ui线程在把url传递给网络线程的同时，会尝试启动一个渲染进程。
 * 如果一切都按照于其正常进行的话，当网络线程拿到数据时，渲染进程就以及处于待命状态了。也会有
 * 例外的情况：比如导航重定向到一个另外的站点，那么预先启动号的渲染进程将不会被使用，这导致ui
 * 线程需要重新启动一个渲染进程
 * step5：触发导航
 * 现在我们假设数据和渲染进程都准备号了，浏览器进程通过ipc告知渲染进程可以触发本次导航了。于此
 * 同时，数据也将传递给渲染进程，这样后者就能继续接收html数据。一旦浏览器收到来自渲染进程的导航
 * 启动信号，本次导航也就完成了，下一步进入文档的加载阶段。
 * 
 * 到这会儿，浏览器的地址栏更新，安全指示符和站点的设置ui回将新页面的信息呈现出来。当前窗口
 * 的session将会更新，刚导航到的页面会被后退/前进按钮级联到窗口的页面历史中。为了方便在关闭
 * 窗口时回复页面，历史的会话记录会保存在本地的磁盘上。
 * 
 * Extra step：初始加载完成
 * 当导航触发后，渲染进程会持续接收资源并渲染页面。我们将在下一篇文章中讨论这一步的更多细节。当
 * 渲染进程“完成”渲染后，它会通过ipc告知浏览器进程（页面的onload事件均已执行完毕后），ui线程
 * 也就不再在tab上转菊花了。
 * 上面的“完成”两个字，之后打了双引号，因为在实际常见中，它通常并真正意味着完成，因为客户端js
 * 可能在此时持续低加载资源并渲染新的视图
 * 
 * 导航到另一个网站
 * 一次简单的导航截至目前已经完成了。加入这时用户输入了一个不同的url会发生什么呢？其实也没什么
 * 浏览器进程会按照上面的步骤导航到这个网站。但这一切之间，浏览器会检查当前已经渲染好的网站
 * 是否需要在网页卸载之前搞一点事情，这就是beforeupload事件。
 * 在beforeunload事件中，我们可以在用户即将跳转至其他页面或者关闭tab的时候发起一个“确认离开
 * 当前页面?”的二次确认。tab中的所有东西都由渲染进程控制着，但也包括开发者编写的js，所以但一个新
 * 的导航请求即将到来时，浏览器进程会堆当前的渲染进程做最后的检查。
 * 
 * 我们应当尽量避免在beforeupload中添加总会执行的事件代码，这会造成更多的交互延时，毕竟他们总会
 * 在新的导航开始之前执行。只在愮的时候添加这些代码，比如提醒用户如果进入新的页面那么当前页面的数据
 * 会丢失。
 * 
 * 如果导航是在渲染进程中被创建出来（比如用户点击了页面上的某一连接或者在js运行了window.location.href
 * ='https://kyrieliu.cn'），则但钱的渲染进程会首先检查beforeupload中是否有东西需要执行。
 * 之后，它会经历与浏览器进程直接发起导航后一样的导航过程。
 * 
 * 当新的导航将发往与当前页面不同的站点时，浏览器回将创建一个新的渲染进程去处理这些新工作，旧得
 * 渲染进程则用来在剩余得时间里处理诸如upload得页面时间。如果你想了解更多得话，可以看看页面生命
 * 周期概览和页面生命周期api这两篇。
 * 
 * 如果有service worker得引入会堆页面得导航流程带来一些改变。service worker是一种可以在应用代码
 * 中编写网络代理得方法；增强了开发者堆本地缓存以及合适发起网络请求得控制。如果service worker
 * 提前设置了从本地缓存惠宗读取某一页面得数据，那么也就不需要发起网络请求了。
 * 需要明确得一点时，即使service worker提供了听起来很高端得功能，但它实质上也是运行在渲染进程
 * 得js代码。那么 问题来了：当用户发起一次导航时，浏览器进程时如何知道目标站但存在一个servie
 * worker得呢？
 * 
 * 当一个service worker注册后， 它得作用域会保存在一个引用中（你可以通过serviceworker的生命
 * 周期这篇文章了解我所说的“作用域”）。当导航发生时，网络线程会依据网络已注册的service worker
 * 作用域集合中查询，如果找到某个对应的serviceworker，ui线程会发起一个渲染进程去执行serviceworker
 * 中的代码。service worker可以从本地缓存中加载数据（武宣发起网络请求）也可以选择通过网络请求
 * 获取最新的资源和数据。
 * 
 * 相信你可以发现，如果service worker最终决定从网络请求数据，那么之前的浏览器进程和渲染进程
 * 之间所发生的通信都将称为导致响应延时的罪魁祸首。导航预加载就是用来加速这一个进程的机制：与
 * service worker并行启动加载资源。当将这些请求设置一个header，有服务端来决定为这些请求发送
 * 不同的内容；比如，仅返回更新的数据而不是整个文档
 * 
 * 
 * part3 | 渲染进程的一生
 * 
 * 这时本系列第三篇文章（3/4），将会讲述浏览器到底怎么样工作的。在之前的文章中，我们介绍了现代
 * 浏览器的多进程架构和导航工作流，在这篇文章中，我们会对渲染进程内部一探究竟。
 * 
 * 渲染进程在很多层面都和页面性能息息相关。考虑到渲染进程内部体系的有很多可以聊的东西，文章只对
 * 其进行一个总体上的概念。如果好奇的你向去了解更多，不妨去看这里
 * 
 * 渲染进行处理web页面的所有内容
 * 
 * 一个浏览器窗口之内发生的所有事情，都是被渲染进程所掌握的。前端工程师们的代码由渲染进程中的
 * 主线程处理。如果使用了webworker或者service worker，那其中的代码将会由worker线程处理。
 * Compositor线程和Raster线程也运行在渲染进程中，他们的作用时高效平滑地渲染出一个页面。
 * 
 * 渲染进程最核心的工作是：将html、css和js代码编程一个可与用户交互的web页面。
 * 
 * 解析文档
 * 构建DOM树
 * 当渲染进程接收到一条即将去导航的信号并开始接收html数据时，主线程就开始了自己的工作：解析html
 * 文本并将其转换为文档对象模型（DOM）
 * 
 * DOM时浏览器内部对一个页面的抽象，也时开发者可以利用js与之相交互的数据解构和api
 * 
 * 浏览器按照html标准去解析html文档。你或许发现了一件事情，就是即使你随便对给浏览器一个html文档
 * 都不会报错。比如没有结束标签的</p>仍然时一段有效的html。一段错误的标签比如：Hi<b>my name is <i>chrome</b>!</i>
 * （b标签在i标签之前提前关闭了）会被当作Hi!<b>I'm<i>chrome</i></b><i>!</i>去对待。这都是因为
 * HTML本身才设计之初就希望优雅的解决这些错误。如果你时个好像的小盆友，可以去看看An Introduction
 * toError Handling and Strage Cases in the Parser这篇文章的相关章节。
 * 
 * 子资源加载
 * 一个网站通常会用到很多外部资源比如图片、css和js。这些文件都需要从网络或者缓存中加载。当主线程
 * 在解析HTML文档的时候发现了这些需要额外加载的资源，主线程会一个一个地区请求，但这样会降低解析
 * html的效率。因此为了提速，“预加载扫描器”闪亮登场了。如果在文档中存在img标签或是link标签，
 * 预加载扫描器会“窥探”到html解析器生成的token，并向浏览器进程中的网络线程发起请求。
 * 
 * js阻塞解析
 * 
 * 当html解析器遇到了script标签时，它会暂停对html的解析工作，转而区加载、解析并执行js代码。
 * 为什么呢？因为js可能改变文档的解构，比如用document.write()之类的函数。这就是为什么html
 * 解析器必须在js执行过后才恢复对html文档的解析工作。如果你的js代码在执行时的事情有兴趣的话，
 * 可以看看v8团队的这篇文章
 * 
 * 告诉浏览器你想怎么样加载资源
 * 
 * 浏览器提供了很多不错的方法给开发者，可以帮助他们用不同的姿势在页面上加载资源。如果你的js代码中
 * 没有用到诸如document.write()之类的代码，你可以在自己的script标签上加上async/defer属性，
 * 浏览器就会异步地加载并执行js代码并不会阻塞对于文档的解析。需要的话，也可以用到js模块。
 * <link rel='preload'>用于加载当前页面一定会用到的资源，并且开发者希望浏览器能在第一时间
 * 加载这些资源。开发者可以针对不同的常见，赋予资源不同的加载优先级，浏览器会按照既定的规则
 * 依次加载这些资源，从而起到加载优化的效果。
 * 
 * 样式的计算
 * 
 * 只有DOM时无法完全知道一个页面最终时什么样子的，因此我们还需要css。主线程在完成对css的解析和
 * 计算后，才会为每个DOM节点赋予最终的样式。你可以在DevTools的Computed中查看到页面的相关信息。
 * 
 * 即使开发者不提供任何的css，每个dom节点还是回有各自的样式<h1>显示的字体比<h2>大、每个元素都
 * 由自己的margin值。这是因为浏览器本身由一个默认的样式表。如果你像知道chrome的默认css是啥，
 * 区看chrome的原代码。
 * 
 * 布局
 * 
 * 现在渲染进程知道了文档的解构和每个节点的样式，但这还不足以区渲染一个页面。想想一个场景，你
 * 试图通过电话沟通告诉你盆友一幅画长什么样子。“有一个红色的大院和一个蓝色方块”，你盆友听到以后
 * 肯定还是一脸懵逼：
 * 
 * 布局时查找元素几何形状的过程。主线程遍历DOM并计算样式，创建了一个具有横纵坐标以及盒子边界
 * 大小数据的布局树（layout tree）。布局树可能于dom树相似，但它只包含和页面即将呈现的节点
 * 相关的信息。如果某个元素设置了display:none，虽然它会呈现在dom树中但并不会包含于布局树中；
 * 如果有一个伪元素p::before{content: 'hi'}，那么它虽然不再dom树中，但仍然会出现在布局树当中
 * 
 * 页面布局的决策是一项很有挑战的工作。即使是最简单的页面布局，比如一个从上至下的块状元素集合，
 * 也需要区决定字体显示多大、在哪里换行...因为这些都会影响到段落的大小和形状，这些也都会影响
 * 到相邻的元素最终会显示在哪里。
 * 
 * css可以让元素悬浮在另一侧，可以将一处的内容隐藏，还可以改变文案的阅读方向。相信你可以想象的到
 * 布局阶段的任务是非常艰巨的。在chrome，一整个团队的工程师都致力于布局这一阶段的工作。如果你想
 * 看看他们都做了哪些工作，这里有一个相关BlinkOn有趣的会议记录可以看看。
 * 
 * 打个闭方，布局就像是你在尽力还原一幅画：你知道大小、形状以及元素的坐标，但你还需要决定先画
 * 哪一个。实际情况是，某个元素可能被设置了z-index，如果按照html的元素编写顺序去“画”，就会导致
 * 错误的渲染效果。
 * 
 * 在这一绘制的过程中，主线程遍历布局树从而去创建绘制记录。绘制记录是绘制进程的“笔记”，记下了
 * 注入“先是背景，然后文字，接下来是矩形的这样的记录”。如果你曾经在canvas上用js画过画，那么
 * 这个过程对你来说就很熟悉了。
 * 
 * 更新渲染的代价是很大的
 * 
 * 在渲染中最需要关注到的事情是，在每一步中，先前的操作都会产生新的数据。举例，如果布局树的某些
 * 东西改变了，文档中相关部分的绘制顺序也需要重新安排一遍。
 * 
 * 如果页面上由动画元素，浏览器会在每一帧都执行2这些操作。大多数浏览器都会以每秒60的频率刷新屏幕
 * 当你以这样的运动速率去微迟动画时，人眼对于动画的感知会是流畅的。然而，如果动画“丢帧”了，页面就会
 * 看起来很不友好。
 * 
 * 即使你的渲染操作跟上了屏幕的刷新频率，但这些计算始终时运行在主线程上的，这就意味着当你的应用
 * 在运行js时，这些都会被阻塞掉。
 * 
 * 你可以将js的操作分割为许多小的块并放在requestAnimationFrame()里执行，或者干脆把这些js丢在
 * web worker里去执行，这样就能避免阻塞主线程。
 * 
 * 合成
 * 
 * 你会怎样画一个页面呢？
 * 现在浏览器知道文档的结构、每个元素的样式、页面的几何构成以及绘制的顺序，它会怎样去绘制一个
 * 页面呢？将这些信息转换为屏幕上的像素，这个过程叫做光栅化。
 * 
 * 处理这个问题有个“幼稚”的办法，就是值对可视区域的部分进行光栅化。当用户滚动页面时移动浏览器的
 * 光栅窗口，从而将剩余的部分渲染出来。实不相瞒，chrome在刚发布的时候，确实用这种方案的。不过
 * 时至今日，现代浏览器的这一过程更为复杂，我们一般称之为合成。
 * 
 * 什么是合成？
 * 
 * 合成是一种将页面的各个部分分为多层，分别对其进行光栅化并在称为合成器线程的单独线程种作为页面
 * 进行合成的技术。如果发生了滚动，因为每一层都已经完成了光栅化，剩下需要做的就是合成出一个窗口
 * 可以通过移动图层并合并新帧来以相同的方式实现动画。
 * 你可以在DevTools的Layers面板种查看你的页面是如何被切分成层的。
 * 
 * 分层
 * 
 * 为了确定每个元素各自应该在哪一层，主线程在遍历了布局树后生成了一个叫做Layer Tree。如果页面的
 * 某一部分需要单独的层级（比如滑入的左侧栏目录）但却没有得到对于的层级，开发者可以用css的will-change
 * 属性来告知浏览器。
 * 
 * 你可能像给每个元素一个单独的渲染层，但是于每帧光栅化页面的小部分相比，在过多数量的图层上进行合成
 * 可能会导致操作的速度编码，因此衡量应用程序的渲染性能也是至关重要的一环。
 * 
 * 主线程的光栅于合成
 * 
 * 一旦layer tree形成并绘制的顺序定下来后，主线程会将这个消息提交给合成线程。然后，合成器线程
 * 将每个图层光栅化。一个图层有可能和整个页面一样大，所以合成器线程将他们切割为很多小块，并将
 * 这些块发送给光栅线程。光栅线程将一小块完成光栅化后将其保存在GPU的内存当中
 * 
 * 合成线程可以有限处理不同的光栅线程，以便可以首先对可视区域种的事物进行光栅化。图层还具有
 * 用于不同分辨率的多个拼贴，以处理注入放大动作之类的事情。
 * 光栅化后，合成器线程将收集成为“Draw Quads”的图块信息以创建合成帧
 * 
 * 合成帧会同ipc被传递给浏览器进程。这时，来自其他ui线程的合成帧可能以及被用于浏览器的ui变化了
 * 合成帧被运送至gpu，目的就是为了显示在屏幕上。如果这时滚动页面，合成器线程又会创建新的合成帧
 * 并将之发送到GPU
 * 
 * 合成的优势是所有的很差操作都是独立于主线程进行的。合成器线程不需要等待样式的计算或者js的执行。
 * 这就是coa能加速页面性能的原因。如果页面的布局或者绘制需要被重新计算，这种情况下主线程就会
 * 被牵扯进来。
 */
function bindClick(){
  $('.process-btn').off('click')
  $('.process-btn').on('click', function(){
    if($(this).hasClass('active')){
      $(this).removeClass('active')
      $('.process-table-wrap').slideUp();
    }else{
      $(this).addClass('active')
      $('.process-table-wrap').slideDown();
    }
  })
}
//重置为初始化状态
function resetState(){
  setTimeout(() => {
    $('.process-wrap .process-btn').removeClass('active')
    $('.process-table-wrap').slideUp();
  })
}